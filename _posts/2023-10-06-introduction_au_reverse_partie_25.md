---
title: Partie 25 - Annexes
date: 2023-10-06 10:00:00
categories: [Reverse, Introduction au reverse]
tags: [x86, reverse, linux]     # TAG names should always be lowercase
author: kabeche
toc: true
---

# Annexes

Dans cette page, vous trouverez plusieurs informations regroup√©es ensemble dont on a pu parler lors de ce cours :

- des astuces **Ida**
- des astuces **gdb**
- les **principales instructions x86**

> Si vous cherchez une info ou commande bien pr√©cise, n'h√©sitez pas √† utiliser `Ctrl+F` üòâ.
{: .prompt-tip }

## Astuces IDA

> **Astuce IDA** : Vous pouvez utiliser le raccourcis `N` pour **renommer** une **fonction**, un **label** ou une **variable** en ayant pr√©alablement cliqu√© dessus avant de la renommer.
{: .prompt-tip }

> **Astuce IDA** : Pour modifier le **type** d'une **fonction** ou d'une **variable**, il suffit de cliquer dessus et d'appuyer sur `Y`.
{: .prompt-tip }

> **Astuce IDA** : Le raccourcis permettant d'assigner √† des constantes des √©num√©rations est `M`.
{: .prompt-tip }

> **Astuce IDA** : Il est possible de mettre un commentaire sur la m√™me ligne que l'instruction s√©lectionn√©e dans la fen√™tre de d√©compilation avec le raccourcis `/`.
> 
> Dans la fen√™tre du code d√©sassembl√©, cela est possible avec `:` ou `;`.
{: .prompt-tip }

> **Astuce IDA** : Vous pouvez utiliser le raccourcis `Inser` pour saisir un commentaire avant l'instruction s√©lectionn√©e.
{: .prompt-tip }

> **Astuce IDA** : En utilisant la touche `Entr√©e`, vous pouvez ajouter des sauts de lignes, pratique lorsque l'on souhaite espacer le code.
{: .prompt-tip }

> **Astuce IDA** : Les variables nomm√©es `v1`, `v2` etc. correspondent √† des **variables locales** d'une fonction tandis que les variables `a1`, `a2` etc. correspondent aux **arguments** de la fonction.
{: .prompt-tip }

> **Astuce IDA** : Vous pouvez utiliser le raccourcis `G` pour aller √† une adresse en particulier.
{: .prompt-tip }

> **Astuce IDA** : Vous pouvez utiliser le raccourcis `espace` pour basculer du mode "graphe" vers le mode "texte" et inversement.
{: .prompt-tip }

> **Astuce IDA** : En mode "graphe", vous pouvez modifier la couleur des blocs de base en cliquant sur l'ic√¥ne la plus √† gauche en haut du bloc.
{: .prompt-tip }

> **Astuce IDA** : Parfois, au lieu d'afficher une cha√Æne de caract√®res, IDA affiche un offset en m√©moire plut√¥t que la `string` directement. Pour y rem√©dier, aller dans `Edit`‚û°Ô∏è `Plugins` ‚û°Ô∏è `Hex-Rays Decompiler` ‚û°Ô∏è `Options` ‚û°Ô∏è `Analysis options 1` et d√©cocher `Print only constant string literals`.
{: .prompt-tip }

> **Astuce IDA** : Il est souvent int√©ressant d'avoir les deux onglets d√©sassembleur / d√©compilateur sur la m√™me vue. Vous pouvez faire cela en d√©pla√ßant l'un des deux onglets. Vous pouvez ensuite synchroniser les deux vues en faisant un clic droit dans la fen√™tre de d√©compilation et en cliquant sur `Synchronize with > IDA View`.
> 
> De cette mani√®re, lorsque vous cliquerez sur un ligne ou que vous changerez de fonction, IDA affichera la ligne ad√©quate dans la fen√™tre de d√©sassemblage. 
{: .prompt-tip }

> **Astuce IDA** : Pour d√©sactiver (ou r√©activer) le *cast* des variables, c'est le raccourcis `Alt Gr + \`. Cela permet d'avoir du code plus lisible.
> 
> Mais attention, parfois les *casts* donnent des informations importantes, notamment lorsque l'on souhaite reprogrammer un algorithme en C, Python ou autre, il est n√©cessaire de faire attention √† la taille des variables.
{: .prompt-tip }

> **Astuce IDA** : Une fois que vous avez trouv√© l'adresse de base de votre programme, il suffit, dans IDA, d'aller dans `Edit` ‚û°Ô∏è `Segments` ‚û°Ô∏è `Rebase program` puis saisir l'adresse de base trouv√©e dans gdb avec `libs` et cliquer sur `Ok`.
{: .prompt-tip }

## Astuces gdb

> Certaines de ces commandes sont propres √† `pwndbg`.
{: .prompt-warning }

Liste des formats : 

- **o** : octal
- **x** : hexad√©cimal
- **u** : d√©cimal non sign√©
- **t** : binaire
- **f** : nombre √† virgule (ou flottant)
- **a** : adresse
- **c** : char
- **s** : cha√Æne de caract√®res

**Tailles** d√©finies dans gdb :

| Abr√©viation | Signification | Taille (en octets) |
|-------------|---------------|--------------------|
| `b`           | *byte*          | 1                  |
| `h`           | *half word*     | 2                  |
| `w`           | *word*          | 4                  |
| `g`           | *giant word*    | 8                  |

> **Astuce gdb** : Si un programme accepte des arguments via `argv`, il est possible de les sp√©cifier lors de la commande `run`.
> 
> Exemple : `run arg1 arg2`
{: .prompt-tip }

> **Astuce gdb** : La commande `hb *0xaddr` (*hardware breakpoint*) permet d'ins√©rer un point d'arr√™t mat√©riel √† l'adresse `0xaddr` .
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez utiliser `i b` (pour `info breakpoints`) afin de lister les points d'arr√™ts du programme.
> 
> Cela est tr√®s utile pour s'y retrouver. Chaque point d'arr√™t ayant un num√©ro unique, il sera affich√© dans cette commande.
{: .prompt-tip }

> **Astuce gdb** : Pour supprimer un point d'arr√™t vous pouvez utiliser  `d N` (pour `delete N`) afin de supprimer le *breakpoint* num√©ro `N`.
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez lister les zones m√©moire mapp√©es avec la commande `libs`.
{: .prompt-tip }

> **Astuce gdb** : L'instruction `starti` permet de charger le programme en m√©moire et de **s'arr√™ter √† la premi√®re instruction** de ce dernier, **sans l'ex√©cuter**.
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez quitter gdb avec les commandes `quit` ou `exit`. De mani√®re plus rapide, vous pouvez utiliser `Ctrl+D`.
{: .prompt-tip }

> **Astuce gdb** : Pour ex√©cuter l'instruction courante et s'arr√™ter √† la prochaine, il est possible d'utiliser `si` ou `ni` (pour `step instruction` et `next isntruction`).
> 
> La diff√©rence entre les deux est que lors de l'appel d'une fonction, `ni` ex√©cute la fonction jusqu'au retour alors que `si` entre dans la fonction et s'arr√™te √† la premi√®re instruction.
{: .prompt-tip }

> **Astuce gdb** : Le fait de saisir √† chaque fois `si` pour avancer d'une instruction peut √™tre fastidieux üò§. Vous pouvez ~~spammer~~ utiliser la touche `Entr√©e` dans le terminal gdb afin de r√©-ex√©cuter la derni√®re commande que vous avez lanc√©e pr√©c√©demment.
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez utiliser la commande `c` (ou `continue`) pour poursuivre l'ex√©cution du processus jusqu'√† arriver √† un point d'arr√™t.
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez utiliser le raccourcis `fin` (ou `finish`) pour finir l'ex√©cution d'une fonction jusqu'√† atteindre l'adresse de retour et s'y arr√™ter.
{: .prompt-tip }

> **Astuce gdb** : La commande `p` (ou `print`) permet d'afficher une valeur quelconque ou la valeur d'une registre.
> 
> Si la valeur √† afficher est une adresse (ou pointeur), elle ne sera pas d√©r√©f√©renc√©e.
{: .prompt-tip }

> **Astuce gdb** : Pour afficher un registre, il suffit de le pr√©fixer avec le signe `$`. Exemple : `print $reg`.
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez utiliser le raccourcis `x` ( pour `explore`) afin d'examiner le contenu d'une zone m√©moire.
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez sp√©cifier un nombre d'√©l√©ments √† afficher avant les formats afin d'afficher plus ou moins de donn√©es en m√©moire. 
{: .prompt-tip }

> Le **nombre d'√©l√©ments** √† afficher ainsi que **la taille** ne sont utilisables qu'avec `x`. Cela ne **fonctionnera pas** avec `print` o√π seuls les formats (d√©cimal, binaire, hexad√©cimal ...) sont utilisables.
{: .prompt-warning }

> **Astuce gdb** : Avec `x`, vous pouvez √©galement donner en argument une expression avec des op√©rations (addition, soustraction, multiplication ...).
> 
> Cela peut √™tre pratique pour afficher une donn√©e dans un tableau dont on connait l'index et l'adresse de base. Par exemple, pour afficher la 5√®me case d'un tableau d'√©l√©ments de 64 bits : `x 0x401000+8*5` (en supposant que le tableau soit stock√© √† partir de l'adresse `0x401000`).
{: .prompt-tip }

> **Astuce gdb** : La commande `search` de pwndbg permet de rechercher des motifs en m√©moire.
{: .prompt-tip }

> **Astuce gdb** : La commande `set` permet d'√©crire dans des registres, variables et la m√©moire.
{: .prompt-tip }

> **Astuce gdb** : Vous pouvez utiliser `rel` (pour `reload`) afin de rafra√Æchir la GUI de pwndbg et voir les changements effectifs.
{: .prompt-tip }

> **Astuce gdb** : Pour modifier une zone m√©moire point√©e par un registre, il est possible d'utiliser `set *$reg = value`.
> 
> Pour modifier directement les donn√©es point√©es par une adresse : `set *0xaddr = value`.
{: .prompt-tip }

> **Astuce gdb** : Si vous ne souhaitez modifier qu'un seul octet (au lieu de 4 par d√©faut) vous devez le sp√©cifier. Exemple : `set {byte}0x401020 = 0xf5`.
{: .prompt-tip }

## Instructions x86

### `mov reg_d, value`

#### Op√©randes 
- `reg_d` : registre de destination
- `value` : valeur imm√©diate (ou concr√®te, constante). 

#### D√©tails 
Cette forme est la plus simple : elle affecte la valeur `value` au registre de destination `reg_d`.

C'est une mani√®re de r√©aliser des affectations de valeurs concr√®tes (imm√©diates).

#### Exemple
Imaginons que `eax` vaille `0xaabbccdd` puis que l'on ex√©cute l'instruction `mov eax, 0xdeadbeef`. Alors la valeur de `eax` deviendra `0xdeadbeef`.

#### √âquivalent en C

```cpp
// Initilisation du registre
int x = 0xaabbccdd; // eax

// Equivalent de : mov eax, 0xdeadbeef
x = 0xdeadbeef;
```

### `mov reg_d, reg_s`

#### Op√©randes 
- `reg_d` : registre de destination
- `reg_s` : registre source 

#### D√©tails 
Le contenu du registre source `reg_s` est copi√© dans le registre de destination `reg_d`.

C'est une mani√®re d'affecter le contenu d'une variable √† une autre.
#### Exemple 

```nasm
mov eax, 0xaabbccdd
mov ebx, 0x11223344 

mov ebx, eax ; ebx == 0xaabbccdd
```

#### √âquivalent en C

```cpp
// Initilisation des registres
int a = 0xaabbccdd; // eax
int b = 0x11223344; // ebx

// Equivalent de : mov ebx, eax
b = a; // b = 0xaabbccdd
```

### `mov reg_d, [reg_p]` 

#### Op√©randes 
- `reg_d` : registre de destination
- `reg_p` : registre pointant vers une zone m√©moire

#### D√©tails 
Cette forme est un peu plus complexe que les pr√©c√©dentes car elle fait appel √† la notion de **pointeur**.

Ici `reg_d` est le registre de destination qui recevra une valeur, jusque-l√† rien de bien nouveau. Par contre, `reg_p` ne contient pas la valeur qui sera copi√©e mais **un pointeur vers la valeur** en question.

Ainsi, c'est la valeur point√©e par `reg_p` qui est copi√©e dans `reg_d`.

C'est une mani√®re de **lire des donn√©es** depuis la **m√©moire**.

#### Exemple
Imaginons que je veuille ex√©cuter ces instructions :

```nasm
mov eax, 0x700000F0 ; 0x700000F0 -> 0x1a2b3c4d
mov ebx, 0xcafebabe

mov ebx, [eax]
```

On suppose √©galement que l'adresse `0x700000F0` pointe vers l'entier de 4 octets `0x1a2b3c4d`. Lorsque la derni√®re instruction `mov ebx, [eax]` sera ex√©cut√©e, alors `ebx` vaudra `0x1a2b3c4d`. Vous voyez la logique ?

#### L√©g√®res variantes

Il existe quelques variantes o√π un offset (positif ou n√©gatif) est ajout√© au registre `reg_p`, par exemple :

```nasm
mov edx, [eax + 8]
mov ecx, [esi - 0x2000]
```

#### √âquivalent en C
Cette forme est tr√®s similaire √† l'utilisation de pointeurs en C :

```cpp
// Initilisation des registres
int *a = 0x700000f0; // eax
int b = 0xcafebabe; // ebx

// Initilisation de la m√©moire 
*a = 0x1a2b3c4d;

// Equivalent de : mov ebx, [eax]
b = *a; // b = 0x1a2b3c4d
```

### `mov [reg_p], reg_s`

#### Op√©randes 
- `reg_p` : registre pointant vers une zone m√©moire
- `reg_s` : registre source

#### D√©tails 
Normalement, si vous avez bien saisi le principe de l'instruction `mov reg_d, [reg_p]` vous devriez deviner le fonctionnement de celle-ci.

En fait il s'agit de l'inverse de la pr√©c√©dente instruction. En effet, ici on copie la valeur du registre `reg_s` vers la zone m√©moire point√©e par `reg_p`.

C'est une mani√®re d'**√©crire des donn√©es** en **m√©moire**.

#### Exemple
Reprenons le pr√©c√©dent exemple, nous avons cette fois-ci :

```nasm
mov eax, 0x700000F0 ; 0x700000F0 -> 0x1a2b3c4d
mov ebx, 0xcafebabe

mov [eax], ebx ; 0x700000F0 -> 0xcafebabe
```

#### L√©g√®res variantes

Il existe quelques variantes o√π un offset (positif ou n√©gatif) est ajout√© au registre `reg_p`. Il est √©galement possible de remplacer `reg_s` par une valeur imm√©diate. Par exemple :

```nasm
mov [ebp + 8], edi
mov [esi - 0x200], 0xdeadbeef
```

#### √âquivalent en C

```cpp
// Initilisation des registres
int *a = 0x700000f0; // eax
int b = 0xcafebabe; // ebx

// Initilisation de la m√©moire 
*a = 0x1a2b3c4d; // 0x700000f0 -> 0x1a2b3c4d

// Equivalent de : mov [ebx], eax
*a = b; // 0x700000f0 -> 0xcafebabe
```

### R√©sum√© des diff√©rentes formes de `mov`

Je sais, √ßa fait beaucoup d'informations d'un coup, voici ainsi un r√©sum√© avec un exemple pour chacun des 4 formes possibles. Supposons que dans les 4 cas l'√©tat initial est le suivant :

![](/assets/images/introduction_au_reverse/init_mov_asm_bis.png)

Alors le r√©sultat est : 

![](/assets/images/introduction_au_reverse/mov_summary.png)

> Les valeurs en üî¥ sont celles qui ont chang√© lors de l'ex√©cutions de l'instruction tandis que celles en ‚ö´ sont les valeurs √† l'origine du changement.
{: .prompt-tip }

### `lea reg, [...]`

#### Op√©randes 
- `reg` : registre de destination
- `[...]` : valeur qui est souvent une adresse m√©moire

#### D√©tails 

Cette instruction a ainsi une seule forme o√π la premi√®re op√©rande est toujours un registre, la seconde op√©rande est une valeur qui est souvent une adresse vers une zone m√©moire. 

Ce que fait `lea` est tout simplement la copie de l'op√©rande de droite, **sans la d√©r√©f√©rencer**, vers le registre de destination.

Voici quelques exemples :

```nasm
lea eax, [0x400000] ; ici eax = 0x400000 
lea edx, [ebp+8]    ; ici edx = ebp +8
lea ecx, [ebx+eax]  ; ici ecx = ebx+eax
```

#### Exemple

> Comme `lea` ne d√©r√©f√©rence pas la seconde op√©rande, l'instruction `lea eax, [0x400000]` copie bien `0x400000` dans `eax` et non pas la valeur point√©e par `0x400000`.
{: .prompt-warning }

En fait, plus simplement, `lea` copie la valeur entre les crochets vers le registre de destination. En d'autres termes, `lea reg, [...]` est √©quivalente √† `mov reg, ...`.

J'en vois d√©j√† certains froncer les sourcils ü§®.

> Mais si cela est √©quivalent √† faire un `mov`, pourquoi se casser la t√™te avec une instruction en plus ?
{: .prompt-info }

En fait, contrairement √† `mov`, l'instruction `lea` permet de faire de petites op√©rations au niveau de l'op√©rande de droite. Par exemple, si je souhaite affecter √† `ecx` la somme de `ebx` et `eax` en utilisant `mov`, je suis oblig√© d'utiliser une instruction suppl√©mentaire telle que `add` pour faire l‚Äôaddition et ensuite stocker le r√©sultat dans `ecx` avec `mov`.

Tandis qu'avec `lea`, je peux simplement faire : `lea ecx, [ebx + eax]`. Vous savez quoi ? On peut m√™me faire `lea ecx, [ebx + eax*2]`üòé.

Ainsi, `lea` permet de :

- **Stocker** le r√©sultat de **simples op√©rations** en √©crivant une seule instruction
- De **manipuler des adresses** en y ajoutant, ou non, un offset

> S'il n'y avait qu'une seule chose √† retenir de `lea` : il s'agit d'un `mov` qui copie la "valeur entre crochets" vers la destination.
{: .prompt-tip }

### `add reg_d, reg_s`

#### Op√©randes 
- `reg_d` : registre de destination
- `reg_s` : registre source

#### D√©tails 

"Add" en anglais signifie "**ajouter**".

Cette instruction r√©alise ainsi deux actions : 
- **addition** de la valeur du registre source avec celui de destination
- **stockage** du r√©sultat (la somme) dans le registre de destination

C'est de cette mani√®re que sont r√©alis√©es les **additions**.

> Lorsque la somme des deux termes d√©passe le plus grand entier que peut stocker le registre de destination, le r√©sultat est tronqu√© pour qu'il puisse y √™tre stock√©
{: .prompt-warning }

#### Exemple

Faisons la somme de `0xf0000034` et `0x20001200` :

```nasm
mov eax, 0xf0000034
mov ebx, 0x20001200

add eax, ebx ; eax = 0x10001234 et non pas 0x110001234 car le r√©sultat est tronqu√© aux 32 bits de poids faible
```
#### √âquivalent en C

```cpp
// Initilisation des registres
int a = 0xf0000034; 
int b = 0x20001200; 

a = a + b;
```

#### Autres formes

Il existe plusieurs autres formes :
- `add reg, value` 
- `add [ptr], value`
- `add reg, [ptr]`

Leur fonctionnement est toujours le m√™me : somme des deux termes et stockage dans l'op√©rande de destination. 

> Toutes les instructions, sauf mention contraire (comme `lea`), d√©r√©f√©rencent les pointeurs vers des zones m√©moire.
> 
> Dans les pr√©c√©dentes formes, ce n'est donc pas le pointeur `ptr` qui est utilis√© dans la somme mais la valeur point√©e par `ptr` qui est `[ptr]` (qui serait `*ptr` en C). 
{: .prompt-warning }

### `and ope_d, ope_s`

#### Op√©randes 
- `ope_d` : op√©rande de destination. Peut √™tre :
	- un **registre**
	- un **pointeur**
- `ope_s` : op√©rande source. Peut √™tre 
	- une **valeur imm√©diate** 
	- un **registre** 
	- un **pointeur** (vers une zone m√©moire) 

#### D√©tails 

L'instruction `and` r√©alise un "**et logique**" entre les bits des deux op√©randes. Le r√©sultat est ensuite sauvegard√© dans la premi√®re op√©rande (qui ne peut donc pas √™tre une valeur imm√©diate).

#### Exemple

```nasm
mov eax, 0xff00ff00
mov ebx, 0xabcdef12

and eax, ebx ; eax = 0xab00ef00
```

#### √âquivalent en C

```cpp
int a = 0xff00ff00; 
int b = 0xabcdef12; 

a = a & b;
```

#### Autres formes

Il existe d'autres [formes](https://c9x.me/x86/html/file_module_x86_id_12.html) en fonction du type d'op√©randes mais le principe est toujours le m√™me.

### `sub ope_d, ope_s`

#### Op√©randes 
- `ope_d` : op√©rande de destination. Peut √™tre :
	- un **registre**
	- un **pointeur**
- `ope_s` : op√©rande source. **Valeur soustraite**. Peut √™tre 
	- une **valeur imm√©diate** 
	- un **registre** 
	- un **pointeur** 

#### D√©tails 

"Sub" provient de "substract" qui signifie **soustraire**.

Cette instruction r√©alise ainsi deux actions : 
- **soustraction** de l'op√©rande source avec l'op√©rande de destination `ope_d - ope_s`.
- **stockage du r√©sultat** (la diff√©rence) dans l'op√©rande de destination

C'est de cette mani√®re que sont r√©alis√©es les **soustractions**.

> Contrairement √† `add`, l'**ordre** des op√©randes est **important** dans `sub`. En effet, en inversant les op√©randes, on inverse le **signe du r√©sultat**.
{: .prompt-warning }

#### Exemple

Faisons la diff√©rence de `0xf0000034` avec `0x10000034` :

```nasm
mov eax, 0xf0000034
mov ebx, 0x10000034

sub eax, ebx ; eax = 0xe0000000
```

#### √âquivalent en C

```cpp
int a = 0xf0000034; 
int b = 0x10000034; 

a = a - b;
```

#### Autres formes

Il existe d'autres [formes](https://c9x.me/x86/html/file_module_x86_id_308.html) mais le principe est toujours le m√™me.

### `cmp ope_d, ope_s`

#### Op√©randes 
- `ope_d` : op√©rande de destination. Peut √™tre :
	- un **registre**
	- un **pointeur**
- `ope_s` : op√©rande source. Peut √™tre :
	- une **valeur imm√©diate** 
	- un **registre** 
	- un **pointeur** 

#### D√©tails 

La comparaison avec `cmp` est effectu√©e d'une mani√®re qui peut nous para√Ætre bizarre. En effet, `cmp` effectue la soustraction suivante `sub ope_d, ope_s` mais sans stocker le r√©sultat. Ainsi le contenu des **op√©randes restent inchang√©es**.

Par contre, quelques *flags* parmi les **EFLAGS** vont √™tre **chang√©s** en fonction des valeurs des op√©randes et du r√©sultat. C'est √† partir de ces EFLAGS que l'on saura si les op√©randes sont **√©gales** ou s'il y en a une plus **grande/petite** que l'autre etc.

> Il est important que vous ayez en t√™te la mani√®re dont les entiers sont repr√©sent√©s en informatique, notamment les entiers sign√©s avec le [compl√©ment √† deux](https://qkzk.xyz/docs/nsi/cours_premiere/donnees_simples/complement_a_deux/1_cours/).
{: .prompt-tip }

Plus pr√©cis√©ment, ce sont les *flags* `ZF`, `SF`, `CF` et `OF` qui nous int√©ressent principalement (et dans une moindre mesure `PF`). Nous les avions d√©j√† vus bri√®vement pr√©c√©demment, profitons-en pour nous rafra√Æchir la m√©moire et rentrer plus dans les d√©tails. 

- `ZF` (Zero Flag) : 
	- **1** si les deux op√©randes sont √©gales. La diff√©rence des deux termes vaut donc 0.
	- **0** si les deux op√©randes sont diff√©rentes.
- `SF` (Sign Flag) :
	- **1** si le bit de poids fort du r√©sultat est non nul. Dans le cas d'une op√©ration sign√©e cela implique qu'il est n√©gatif. Dans le cas o√π elle est non sign√©, ce *flag* n'a pas d'importance.
	- **0** si le bit de poids fort du r√©sultat est nul
	- **Exemple** : Prenons la soustraction sign√©e suivante :`0x5 - 0x20 = -0x1b`. Le r√©sultat √©tant n√©gatif, le compl√©ment √† deux de `0x1b` est `0xe5` qui s'√©crit sur 8 bits en binaire `0b11100101`. Le bit de poids fort √©tant √† `1`, `SF` l'est √©galement. Etant donn√© qu'il s'agit d'une op√©ration sign√©e `SF` nous permet de savoir que le r√©sultat est n√©gatif.
- `CF` (Carry Flag) :
	- **1** si le r√©sultat poss√®de une retenue. 
	- **0** si le r√©sultat ne poss√®de pas de retenue
	- **Exemple** : Par exemple, pour l'instruction `add al, bl` sur 8 bits o√π `al` vaut `0xFF` et `bl` vaut `0x01`, le r√©sultat est `0xFF + 0x01 = 0x100` qui ne tient pas sur les 8 bit de `al`. Cela g√©n√®re donc une retenue. Lors d'une soustraction `a - b`, **une retenue est g√©n√©r√©e** lorsque `b` est plus grand que `a`.
- `OF` ([Overflow Flag](https://fr.wikipedia.org/wiki/Indicateur_de_d%C3%A9bordement)) :
	- **1** si un d√©bordement a lieu avec des valeurs sign√©es. Par exemple, cela peut avoir lieu lorsqu'il y a un r√©sultat n√©gatif d'op√©randes positifs et inversement. Ce bit n'a pas d'importance lorsque l'on manipule des valeurs non sign√©es.
	- **0** s'il n'y a pas eu de d√©bordement
	- **Exemple** : Prenons l'addition sign√©e suivante :`0x7F + 0x8 = 0x87`. Ici, le bit de poids fort de `0x87` est √† `1` : il s'agit donc d'un r√©sultat n√©gatif (`-121`). Pourtant, les deux termes sont strictement positifs. Il y a donc eu un d√©bordement (`overflow`).
- `PF` (Parity Flag) :
	- `1` si le nombre de bits su r√©sultat est pair
	- `0` sinon

> N'h√©sitez pas √† utiliser [asmdebugger](http://asmdebugger.com/) pour faire **quelques tests**. Les 4 `flags` √©tudi√©s sont affich√©s sur le site lors de l'ex√©cution des instructions.
> 
> En effet, si l'utilisation de ces *flags* vous para√Æt difficile, sachez que c'est normal car cela fait intervenir des notions que l'on utilise pas, en tant qu'humain, tous les jours comme le compl√©ment √† deux pour repr√©senter des nombres n√©gatifs. 
{: .prompt-tip }

Lors d'une comparaison avec `cmp`, le processeur ne sait pas si les op√©randes sont sign√©es ou non. En fait, il s'en moque √† ce stade. C'est pourquoi il va modifier, si besoin est, ces 4 *flags* bien que certains soient plut√¥t utilis√©s lors d'op√©rations sign√©es (`SF` et `OF`) ou non sign√©es (`CF`).

#### Exemples

Voici quelques exemples :

| Instruction  | ZF | SF | CF | OF |
|--------------|----|----|----|----|
| `cmp 1, 5`     |    |  ‚úÖ  | ‚úÖ   |    |
| `cmp 5, 1`     |    |    |    |    |
| `cmp 5, 5`     |  ‚úÖ  |    |    |    |
| `cmp 4, 255`   |    |    |  ‚úÖ  |    |
| `cmp 127, 129` |    |  ‚úÖ  |  ‚úÖ  |  ‚úÖ  |

Je vous conseille de repr√©senter les entiers sous forme binaire et de faire attention √† la repr√©sentation du compl√©ment √† deux. En effet, `129` s'il n'est pas sign√© vaut `129` mais s'il est sign√©, il vaut `-127`.

#### √âquivalent en C

Pour l‚Äôinstruction `cmp`, il n'y a pas r√©ellement d'√©quivalent en C. En fait, `cmp` n'est jamais (sauf exceptions) utilis√©es autrement qu'avec des sauts. Ainsi, repr√©senter `cmp` tout seul dans du code C n'a pas de sens. Par contre, dans toutes les conditions du type `if`, `else` vous y trouverez un `cmp` (ou `test`) dans le code assembleur associ√©.

### `test ope_d, ope_s`

#### Op√©randes 
- `ope_d` : op√©rande de destination. Peut √™tre :
	- un **registre**
	- un **pointeur**
- `ope_s` : op√©rande source. Peut √™tre :
	- une **valeur imm√©diate** 
	- un **registre** 

#### D√©tails 

Cette instruction est √©galement utilis√©e pour r√©aliser des comparaisons mais son fonctionnement sous-jacent est diff√©rent de `cmp`. 

`test` va ex√©cuter l'instruction `and ope_d, ope_s` sans stocker le r√©sultat mais en mettant √† jour des *flags* suivants : `SF`, `ZF` et `PF`. `test` est souvent utilis√© pour savoir si un registre est nul ou non.

#### Exemple

L'instruction `test eax, eax` permet de voir si `eax` est **nul ou non**. En effet, lors de l'ex√©cution de cette instruction, si `ZF == 1`, c'est que `eax` est nul. Sinon, cela signifie qu'il est non nul.

#### √âquivalent en C

M√™me remarque que pour `cmp` : il n'y a pas r√©ellement d'√©quivalent direct en C.

### `jmp dest`

#### Op√©randes 
- `dest` : destination du saut. Peut √™tre :
	- une **valeur imm√©diate** (exemple : adresse **relative** ou **absolue**)
	- un **registre**
	- un **pointeur**

#### D√©tails 

Unique instruction permettant de r√©aliser des **sauts inconditionnels** afin de "sauter" vers l'adresse de destination. Cela permet de pouvoir ex√©cuter des instructions qui ne sont pas toujours situ√©es lin√©airement dans le code.

> La diff√©rence entre un saut et un appel de fonction `call` est que l'on ne se pr√©occupe pas de sauvegarder **l'adresse de retour** afin de pouvoir y retourner plus tard.
{: .prompt-tip }

Lorsque l'op√©rande `dest` est une valeur imm√©diate, il peut s'agir d'une adresse **absolue** ou **relative** :

- adresse **absolue** : l'adresse est "**cod√©e en dur**" dans l'opcode de l'instruction. Cela permet de sauter **plus loin** dans le code mais l'instruction prend plus de place.
	- Exemple : `e9 d8 12 00 00          jmp    0x12dd`
- adresse **relative** : seule la **diff√©rence** entre l'adresse courante de `eip` et l'adresse de destination est ins√©r√©e dans l'opcode. Cela permet d'avoir des opcodes plus courts mais de sauter **moins loin**.
	- Exemple : `eb 2a                   jmp     short 0x12DC`

> Concernant les adresses absolues, elles ne sont pas ins√©r√©es **tel quel** dans l'opcode. En effet, il est n√©cessaire de prendre en compte **la taille de l‚Äôinstruction** de saut (par exemple 5 octets) avant d'ins√©rer l'adresse de destination. C'est pourquoi l'opcode de l'exemple contient `e9 d8 12` et non pas `e9 dd 12`.
{: .prompt-tip }

Bien que le mn√©monique `jmp` utilis√© soit le m√™me, il existe diff√©rentes forme o√π `dest` n'est pas toujours une adresse. Cela peut, en effet, √™tre un **pointeur** ou **registre**. 

Le souci, en tant que *reverser*, est qu'il ne sera **pas toujours possible de savoir** directement vers quelle adresse le processeur va sauter lorsqu'un registre (ou pointeur) va √™tre utilis√©. En analyse statique, il sera n√©cessaire de d√©terminer les diff√©rentes valeurs que peut prendre le registre afin de trouver les **potentielles destinations**.

Le fait d'utiliser un registre comme op√©rande est tr√®s commun dans la mod√©lisation des `switch` en assembleur apr√®s compilation.

#### Exemple

```nasm
jmp 0x401020
jmp rax
jmp [ebx]

```

#### √âquivalent en C

Les sauts inconditionnels `jmp` sont l'√©quivalent de `goto` en C :

```cpp
#include <stdio.h>

int main() {
    int i = 0;

    start_loop:

    if (i < 5) {
        printf("i = %d\n", i);
        i++;
        goto start_loop;  // Sauter √† l'√©tiquette start_loop
    }

    return 0;
}
```

### `jcc dest`

#### Op√©randes 
- `dest` : destination du saut. Peut √™tre :
	- une **valeur imm√©diate** (exemple : adresse **relative** ou **absolue**)

#### D√©tails 

`jcc` n'est **pas un mn√©monique** en soi. Il s'agit d'un terme g√©n√©rique pour d√©signer le mn√©monique de tous les **sauts conditionnels**. Les points communs de tous ces sauts sont les suivants :

- Ils utilisent certains *flags* parmi les EFLAGS afin de savoir s'il faut sauter
- Lorsque que le saut n'est pas ex√©cut√©e, c'est l‚Äôinstruction **situ√©e imm√©diatement apr√®s** le saut qui est r√©alis√©e
- Ils sont **pr√©c√©d√©s** d'une instruction `cmp` ou `test`

Si vous retenez √ßa, vous avez retenu 60% du fonctionnement des sauts conditionnels. Le reste consiste seulement √† se rappeler de ce que signifie chaque mn√©monique et quels *flags* sont utilis√©s.

Voici les principaux sauts que vous pourrez rencontrer :

> Selon le d√©sassembleur utilis√©, il peut y avoir quelques **diff√©rences** dans le mn√©monique comme `jz` (*jump if zero*) qui peut √™tre d√©sign√© `je` (*jump if equal*) mais qui repr√©sentent exactement la m√™me instruction.
{: .prompt-tip }

| Mn√©monique(s)      | Description                                    | Signe des op√©rations | Cas d'utilisation                   | Condition de saut     |
|-----------------|------------------------------------------------|----------------------|-------------------------------------|-----------------------|
| `jo`              | **J**ump if **o**verflow                               |                      | D√©tection de d√©bordement            | `OF == 1`               |
| `jno`             | **J**ump if **n**ot **o**verflow                           |                      | D√©tection de d√©bordement            | `OF == 0`               |
| `js`              | **J**ump if **s**ign                                   |                      | Tester le signe                     | `SF == 1`               |
| `jns`             | **J**ump if **n**ot **s**ign                               |                      | Tester le signe                     | `SF == 0`               |
| `jz` / `je`         | **J**ump if **z**ero / **e**qual                           |                      | Tester l'(in)√©galit√©                | `ZF == 1`               |
| `jnz` / `jne`       | **J**ump if **n**ot **z**ero / **n**ot **e**qual                   |                      | Tester l'(in)√©galit√©                | `ZF == 0`               |
| `jb` / `jnae` / `jc`  | **J**ump if **b**elow / **n**ot **a**bove or **e**qual / **c**arry     | Non sign√©            | Tester la sup√©riorit√© / inf√©riorit√© | `CF == 1`               |
| `jnb` / `jae` / `jnc` | **J**ump if **n**ot **b**elow / **a**bove or **e**qual / **n**ot **c**arry | Non sign√©            | Tester la sup√©riorit√© / inf√©riorit√© | `CF == 0`               |
| `jbe` / `jna`       | **J**ump if **b**elow or **e**qual / not **a**bove             | Non sign√©            | Tester la sup√©riorit√© / inf√©riorit√© | `CF == 1 \|\| ZF == 1`  |
| `jnbe` / `ja`       | **J**ump if **n**ot **b**elow or **e**qual / **a**bove             | Non sign√©            | Tester la sup√©riorit√© / inf√©riorit√© | `CF == 0 && ZF == 0`    |
| `jl` / `jnge`       | **J**ump if **l**ess / **n**ot **g**reater or **e**qual            | Sign√©                | Tester la sup√©riorit√© / inf√©riorit√© | `SF != OF`              |
| `jnl` / `jge`       | **J**ump if **n**ot **l**ess / **g**reater or **e**qual            | Sign√©                | Tester la sup√©riorit√© / inf√©riorit√© | `SF == OF`              |
| `jng` / `jle`       | **J**ump if **n**ot **g**reater / **l**ess or **e**qual            | Sign√©                | Tester la sup√©riorit√© / inf√©riorit√© | `ZF == 1 \|\| SF != OF` |
| `jg` / `jnle`       | **J**ump if **g**reater / **n**ot **l**ess or **e**qual            | Sign√©                | Tester la sup√©riorit√© / inf√©riorit√© | `ZF == 0 && SF == OF`   |

Il est √† noter qu'il n'existe pas une seule mani√®re de repr√©senter une condition du C vers l'assembleur. Prenons par exemple le code suivant :

```cpp
unsigned int x = ...;
unsigned int y = ...;
if (x > y )
{
	// Code A
}
else
{
	// Code B
}
```

On peut tr√®s bien faire :
```nasm
cmp x, y
ja addr_code_A
code_B
```

ou :

```nasm
cmp x, y
jbe addr_code_B
code_A
```

Il faut donc √™tre attentif lorsque l'on analyse du code assembleur pour savoir ce qui va √™tre ex√©cut√© et sous quelles conditions.

#### Exemples
```nasm
jz 0x555555550102
jns 0x405987
```

#### √âquivalent en C

Selon le **signe des variables** compar√©es et le **type de comparaison** utilis√©, certains sauts vont √™tre utilis√©s plut√¥t que d'autres (les diff√©rents mn√©moniques d'une m√™me instruction ont √©t√© omis par souci de concision) :

```cpp
int x = ...;
int y = ...;

if (x < 0) // js ou jns
{
	//...
}

if (x == y) //jz ou jnz
{
	//...
}

if(x < y) // jl ou jnl 
{
	//...
}

if(x >= y) // jnl ou jl
{
	//...
}

if(x <= y) // jle ou jnle
{
	//...
}

```

#### Autres formes

Il existe d'autres [sauts](http://unixwiz.net/techtips/x86-jumps.html) mais que l'on rencontre moins souvent.

### `cdq`

#### Op√©randes 
- Cette instruction n'a pas d'op√©randes

#### D√©tails 

`cdq` est l'abr√©viation de `convert dword to qword`. Vous l'avez compris, cela devrait donc permettre de convertir un `dword` (4 octets) en un `qword` (8 octets), mais comment ? 

Tout d'abord, cette instruction ne s'applique que sur le registre `eax` (ou ses d√©riv√©es). C'est pourquoi elle ne dispose pas d'op√©randes. De plus, cette instruction garde le signe de l'ancienne valeur lors de la conversion vers la nouvelle valeur.

En x86_64 on a des registres de 64 octets, ce qui n'est pas le cas en x86. Ainsi, pour doubler la taille des donn√©es contenues dans `eax`, c'est le registre `edx` (ou ses d√©riv√©es) qui va √™tre utilis√© de cette mani√®re :

- si le nombre dans `eax` est **n√©gatif** (bit de poids fort √©gal √† `1`), alors `edx` est rempli de `1`
- si le nombre dans `eax` est **positif** (bit de poids fort √©gal √† `0`), alors `edx` est rempli de `0`

> Cette mani√®re de g√©n√©rer une nouvelle valeur √† partir d'une valeur sign√©e est ce que l'on appelle l'**extension de signe**.
{: .prompt-tip }

Ainsi on obtient une valeur de taille double en concat√©nant les deux registres sous la forme : `edx:eax`.

Cette instruction est tr√®s utilis√©e lors des divisions sign√©es afin d'avoir un r√©sultat coh√©rent et correct.
#### Exemples
```nasm
mov eax, 0x70001234
cdq ; edx:eax = 0x00000000:0x70001234

mov eax, 0x80001234
cdq ; edx:eax = 0xffffffff:0x80001234
```

#### √âquivalent en C

Il n'y pas a pas d'√©quivalent directe en C.

#### Autres formes

Il existe plusieurs d√©riv√©es mais dont le principe d‚Äôextension de signe est le m√™me :

- `cwd` (`convert word to dword`): la valeur convertie est contenue dans `dx:ax`
- `cqo` (`convert qword to double qword`): la valeur convertie est contenue dans `rdx:rax` (disponible seulement en x86_64)

### `shr ope_d, n` et `sar ope_d, n`

#### Op√©randes 
- `ope_d` : op√©rande de destination. Peut √™tre :
	- un **registre**
	- un **pointeur**
- `n` : op√©rande source. Peut √™tre :
	- une **valeur imm√©diate** 
	- un **registre** (seulement le registre `cl`)

#### D√©tails 

L'instruction `shr` (ou `shift right`) permet de r√©aliser un d√©calage des bits de `ope_d` de `n` bits vers la droite. 

> Avec l'instruction `shr` et toutes les autres instruction de `shift` (d√©calage), il n'y a pas de rotation des bits sortants.
> 
> Il existe d'autres instructions comme `ror`/`rol` qui r√©alise un d√©calage rotatif des bits. C'est-√†-dire que des bits qui sortent, par exemple, par la gauche, "rerentrent" par la droite. 
{: .prompt-warning }

Ainsi, le d√©calage de `0b01110011` d'un bit vers la droite est `0b00111001`.

> En fait, lorsqu'il y a un bit sortant, il n'est pas r√©ellement perdu dans la nature : il est sauvegard√© dans le *flag* `CF` des EFLAGS. 
{: .prompt-tip }

Il existe l'instruction `sar` (ou `shift aritmetic right`) est bas√©e sur le m√™me principe de d√©calage que `shr`. La seule diff√©rence est que `sar` **prend en compte le signe** du nombre qui sera d√©cal√©.

Ainsi, si le bit de poids fort de `ope_d` est `1`, il sera r√©initialis√© √† `1` apr√®s d√©calage. En fait `sar` agit en deux temps :

1. ex√©cuter `shr` 
2. si le pr√©c√©dent nombre √©tait **sign√©**, mettre le **bit de poids fort** du r√©sultat √† `1`

Voir les exemples ci-dessous pour comprendre de quoi il s'agit.

Ces instructions sont tr√®s utilis√©es pour r√©aliser des divisions par 2 d'un nombre (et dont le reste est dans le *flag* `CF`). En effet, le d√©calage d'un bit vers la droite revient √† diviser par `2`. Le d√©calage de `n` bits vers la droite revient √† diviser par `2 puissance n`.

> Je ne vois pas en quoi d√©caler d'un bit vers la droite revient √† diviser par deux ?
{: .prompt-info }

Pourtant c'est bien ce qui se passe lorsque l'on note un nombre en d√©cimal et que l'on le d√©cale d'une unit√© vers la droite, cela revient √† diviser par 10. 

Prenons par exemple `213950`, en le d√©calant d'une unit√© vers la droite on obtient `21395`, ce qui revient bien √† diviser par 10.

Avec la notation en binaire, c'est la m√™me chose : **d√©caler d'un bit revient √† diviser par deux**.

Ainsi, `sar` et `shr` sont tr√®s utilis√©s pour r√©aliser des divisions de puissances de 2.

#### Exemple

```nasm
    mov eax, 0x80000001   (0b10.....001)
    shr eax, 1 ; eax = 0x40000000 (0b01.....000)
               ; CF == 1
               
    mov eax, 0x80000001   
    sar eax, 1 ; eax = 0xc0000000 (0b11.....000)
               ; CF == 1
```

#### √âquivalent en C

```cpp
int x = 0x80000001;
x = x >> 1; // x = 0xc0000000

int y = 0xdeadbeef;
y = y >> 13; // y = 0xfffef56d
```

#### Autres formes

De la m√™me mani√®re que `shr`/`sar` permettent de r√©aliser des d√©calages vers la droite, `shl`/`sal` permettent de r√©aliser des d√©calages vers la gauche avec le m√™me principe.

A l'instar de la **division par puissances de 2** de `shr`/`sar`, `shl`/`sal` permettent de r√©aliser des **multiplications par puissances de 2** :

- ‚û°Ô∏è `shr`/`sar` : **division par puissances de 2**
- ‚¨ÖÔ∏è`shl`/`sal` : **multiplication par puissances de 2**

Vous pouvez √©galement jeter un ≈ìil aux [instructions](https://c9x.me/x86/html/file_module_x86_id_273.html) `rcl`/`rcr`/`rol`/`ror`. Leur fonctionnement de d√©calage est le m√™me. La **principale diff√©rence** est qu'il y a une **rotation des bits** sortants.