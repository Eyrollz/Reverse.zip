---
title: Partie 15 - Le d√©compilateur - les principaux raccourcis et fonctionnalit√©s (2/3)
date: 2023-10-16 10:00:00
categories: [Reverse, Introduction au reverse]
tags: [x86, reverse, linux]     # TAG names should always be lowercase
author: kabeche
toc: true
---

# Le d√©compilateur : les principaux raccourcis et fonctionnalit√©s

Avant de vous partager un petit challenge de *reverse*, je vous propose de voir ensemble les principaux **raccourcis** et **fonctionnalit√©s** que l'on peut utiliser dans le d√©compilateur d'IDA.

> Il ne va pas √™tre possible de ma√Ætriser lors de ce petit cours **toutes les fonctionnalit√©s** d'IDA mais au moins d'√™tre capable de modifier au mieux une fonction d√©compil√©e pour en comprendre le fonctionnement.
{: .prompt-tip }

> Si vous ne vous souvenez plus de l'utilit√© et du fonctionnement des diff√©rents onglets dans IDA, n'h√©sitez pas √† vous rafra√Æchir la m√©moire dans le chapitre **"Analyse statique  d'un mini-programme : introduction"**.
{: .prompt-tip }

## Le programme utilis√©

Voici le programme de test que je vous propose d'utiliser :

```cpp
#include <stdio.h>  
#include <stdlib.h>  
  
// Enum pour les op√©rations  
enum Operations {  
   ENCRYPT,  
   DECRYPT,  
   INVALID_1,  
   INVALID_2,  
   INVALID_3  
  
};  
  
// Structure pour stocker les donn√©es √† chiffrer  
struct Data {  
   int value;  
   char name[20];  
};  
  
// Fonction de chiffrement  
void encryptData(struct Data *data) {  
   data->value *= 2;  
   printf("Donn√©es chiffr√©es : value = %d, name = %s\n", data->value, data->name);  
}  
  
// Fonction de d√©chiffrement  
void decryptData(struct Data *data) {  
   data->value /= 2;  
   printf("Donn√©es d√©chiffr√©es : value = %d, name = %s\n", data->value, data->name);  
}  
  
// Fonction principale  
int main(int argc, char **argv) {  
   struct Data myData = {10, "Secret"};  
  
   enum Operations operation = atoi(argv[1]) % 5;    
  
   switch (operation) {  
       case ENCRYPT:  
           encryptData(&myData);  
              
           break;  
       case DECRYPT:  
           decryptData(&myData);  
           break;  
       case INVALID_1:  
           puts("Ce cas est invalide !");  
           break;  
       case INVALID_2:  
           puts("Ce cas est aussi invalide !");  
           break;  
       case INVALID_3:  
           puts("Encore invalide !");  
           break;  
     default:  
           printf("Op√©ration invalide !\n");  
           break;  
   }  
  
   return 0;  
}
```

Le programme est assez d√©bile, g√©n√©r√© √©videmment par sheikh GPT ü§ñ, mais contient assez d'√©l√©ments pour voir quelques raccourcis que l'on utilise tr√®s souvent sous IDA. 

Pour le compiler, comme d'hab `gcc -m32 -fno-pie -fno-stack-protector main.c -o cipher`. Je vous conseille de faire une copie du programme nomm√©e `cipher_strip` afin de *stripper* le programme avec `strip`. Enfin, ouvrez le programme `cipher_strip`.

Si vous souhaitez avoir la m√™me version du programme que celle du cours, vous pouvez la t√©l√©charger ici : [cipher_strip](https://drive.proton.me/urls/4HRC0GMK7G#zfGt5xjScfad).

## üî¨ L'analyse

### üîé Trouver le `main`

Comme le programme est stripp√©, il va falloir trouver quelle fonction correspond au `main`. Normalement, en allant dans `start` et en d√©compilant la fonction, vous devriez trouver la fonction `main`. Nous avons fait cela au pr√©c√©dent chapitre.

### Du travail encore du travail ...

Voici √† quoi elle ressemble (il peut y avoir des diff√©rences en fonction du compilateur et options de compilations que vous avez utilis√©es) :

![](/assets/images/introduction_au_reverse/strip_main.png)

Pas besoin d'√™tre un g√©nie du *reverse* pour s'y retrouver par rapport au code source utilis√© en constatant tout de m√™me quelques diff√©rences :

- les noms des **fonctions internes** ont disparu
- les **noms des variables** sont perdus
- la **forme de notre structure** semble inexistante
- `char **argv` est devenu ... un `int` ! Je vous ai dit qu'IDA fait parfois d'√©normes raccourcis, m√™me Google Maps aurait pas os√© ...

![](/assets/images/introduction_au_reverse/same_types.png)

### üî† Renommage des fonctions et variables
#### Les fonctions

Tout d'abord commen√ßons par renommer les fonctions vu que l'on sait √† quoi elle correspondent. Commen√ßons par renommer `sub_122B` en `main`

> **Astuce IDA** : Vous pouvez utiliser le raccourcis `N` pour **renommer** une **fonction** ou une **variable** en ayant pr√©alablement cliqu√© dessus avant de la renommer.
{: .prompt-tip }

Vous devriez avoir quelque chose comme :

![](/assets/images/introduction_au_reverse/renomme_main.png)

> Je ne sais pas pourquoi mais parfois, m√™me apr√®s avoir modifi√© le nom d'une fonction, IDA lui redonne le nom initial. Cela peut arriver lorsque l'on quitte la fonction puis que l'on revient dessus.
> 
> Il suffit de **relancer la d√©compilation** avec `F5` pour que le changement soit affich√©.
{: .prompt-tip }

Vous pouvez √©galement renommer les deux premi√®res fonctions du `switch` en respectivement `f_encryptData` et `f_decryptData`.

> Personnellement j'aime bien renommer les fonctions d√©compil√©es du programme en les pr√©fixant avec `f_`. Cela permet ensuite de retrouver plus facilement celles qui ont √©t√© renomm√©es par rapport √† celles qui √©taient d√©j√† bien nomm√©es.
> 
> Ce n'est pas une convention stricte, d'autres utilisent le pr√©fixe `mw_` lorsqu'ils *reverse* des fonctions d'un malware, vous avez le choix ! L'id√©e est simplement de s'y retrouver et facilement distinguer ce qui a √©t√© modifi√© ou non.
{: .prompt-tip }

#### Les variables

> **Astuce IDA** : Les variables nomm√©es `v1`, `v2` etc. correspondent √† des **variables locales** d'une fonction tandis que les variables `a1`, `a2` etc. correspondent aux **arguments** de la fonction.
{: .prompt-tip }

Normalement, toutes les fonctions appel√©es par le `main` ont √©t√© renomm√©es, on peut alors s'attaquer aux variables.

Le raccourcis pour modifier le nom d'une variable est le m√™me que pour celui d'une fonction : `N`. Vous ne pouvez pas donner le m√™me nom de variable √† deux variables diff√©rentes dans une m√™me fonction mais IDA vous propose alors d'ajouter un **suffixe automatiquement** pour les distinguer.

> J'ai voulu renommer les variables `a1` et `a2` en `argc` et `argv` mais IDA l'a d√©j√† fait, comment ü§Ø ?
{: .prompt-info }

En fait, lorsque l'on a renomm√© la fonction `sub_122B` en `main`, IDA s'est rattrap√© et a **corrig√© la signature** de la fonction qui devient alors : `int __cdecl main(int argc, const char **argv, const char **envp)`, tant mieux ! Mais il nous reste du boulot avec les variables locales restantes.

On peut d'ores et d√©j√† renommer la variable `v4` appel√©e via `f_encryptData(&v4)` qui correspond √† `myData`. Le soucis est que, m√™me apr√®s renommage, `myData` n'a pas le bon type comme vous pouvez le constater :

![](/assets/images/introduction_au_reverse/renamed_myData.png)

Pour rappel notre structure de base √©tait :
```cpp
struct Data {  
   int value;  
   char name[20];  
};
```

Or IDA consid√®re notre structure de 24 octets en plusieurs variables. Il va donc falloir modifier le type de la variable.

> **Astuce IDA** : Pour modifier le **type** d'une **fonction** ou d'une **variable**, il suffit de cliquer dessus et d'appuyer sur `Y`.
{: .prompt-tip }

> Je ne sais pas si cela a √©t√© patch√© depuis mais **modifier le nom d'une variable** avec `Y` en **m√™me temps que le type** ne fonctionne pas et n'aura aucun effet sur le nom de la variable.
> 
> Il faut donc **modifier le type** de la variable dans un premier temps **puis modifier son nom** dans un second temps üò¥. 
{: .prompt-warning }

![](/assets/images/introduction_au_reverse/ida_meme_bis.png)

### La cr√©ation de structure

Avant de pouvoir modifier le type de la variable `myData`, il est n√©cessaire de cr√©er la structure idoine. Pour y parvenir, deux choix s'offrent √† vous :

- utiliser l'onglet `Structures` (`View`‚û°Ô∏è `Open subviews` ‚û°Ô∏è`Structures`)
- utiliser l'onglet `Local types` (`View`‚û°Ô∏è `Open subviews` ‚û°Ô∏è`Local types`)

Personnellement je trouve l'onglet `Local types` bien **plus facile** √† manipuler : on peut directement entrer la structure au format C. Dans `Structures` nous pouvons soit utiliser des structures existantes (peut √™tre tr√®s utile !) soit en cr√©er mais il faut bien g√©rer tous les offsets de la structure.

Je vous proposer de le faire avec `Local types`. En allant dans cet onglet, utilisez le raccourcis `Inser` pour copier / coller notre structure comme ceci :

![](/assets/images/introduction_au_reverse/struct_Data_Ida.png)

Lorsque l'on appuie sur `Ok`, on voit bien que notre structure a √©t√© ajout√©e dans l'onglet. On peut alors retourner dans l'onglet de d√©compilation `Pseudocode-A`. Cliquez sur `myData` puis `Y` pour modifier son type en `struct Data myData` puis confirmez. IDA nous affiche alors ce message :

![](/assets/images/introduction_au_reverse/cvrt_warning_ida.png)

Cela peut faire peur mais IDA veut simplement souligner que le nouveau type de `myData` (`struct Data`) est **plus grand** en termes de taille que l'ancien type `int`, ainsi, cela risque d'√©craser les variables qui la suivent imm√©diatement.

En ce qui nous concerne, comme notre structure `myData` a bien √©t√© stock√©e en tant que variable locale, vous pouvez cliquer sur `Set the type`.

Toutefois, de mani√®re g√©n√©rale, lorsque vous verrez ce message posez-vous la question suivante : est-ce qu'il s'agit d'une structure **stock√©e en tant que variable locale** dans la pile ou est-ce finalement un **pointeur** vers une structure stock√©e ailleurs ?

G√©n√©ralement, la r√©ponse est **affirmative** √† la **seconde question** car on a tendance √† utiliser les structures avec des pointeurs vers les structures lorsque l'on les manipule.

A ce stade, en termes de renommage, il ne nous reste plus qu'√† renommer la derni√®re variable non renomm√©e : la valeur de retour de `atoi` qui est `operation`.

> Mais pourquoi on a les deux fonctions `strcpy` et `memset` dans le code d√©compil√© alors que l'on a jamais appel√© ces fonctions dans le code source ?
{: .prompt-info }

![](/assets/images/introduction_au_reverse/added_functs.png)

Bien vu Watson ! Vous remarquerez que ces le nom de ces fonctions est **en bleu** contrairement aux autres fonctions de la libc qui est **en rose**. De plus, en double cliquant dessus, aucune fen√™tre vers ces fonctions ne s'ouvre ...

En fait, il s'agit tout simplement de la fa√ßon dont IDA voit le stockage de cette *string* :

```cpp
struct Data myData = {10, "Secret"};
//                         ^^^^^^
```

IDA a traduit les instructions assembleur qui correspondent au chargement de `"Secret"` sur la pile comme si `strcpy` √©tait appel√©e puis `memset` pour mettre √† 0 le reste. C'est assez cool car cela permet de comprendre facilement en C via le code d√©compil√© ce qu'il se passe en assembleur.

### La gestion des √©num√©rations

A ce stade vous devriez avoir quelque chose proche de ceci :

![](/assets/images/introduction_au_reverse/before_enums.png)

Pour faciliter la compr√©hension du code, que diriez-vous de remplacer les `case 0`, `case 1` etc. par des `enums` ?

L√† encore vous avez deux choix possibles :

- utiliser l'onglet `Enums` (`View`‚û°Ô∏è `Open subviews` ‚û°Ô∏è`Enumerations`)
- utiliser l'onglet `Local types` (`View`‚û°Ô∏è `Open subviews` ‚û°Ô∏è`Local types`)

Pour les m√™mes raison que pr√©c√©demment, je pr√©f√®re utiliser l'onglet `Local types` pour pouvoir copier/coller le code de l'`enum` sans devoir ajouter les diff√©rentes valeurs de l'√©num√©ration une √† une ni me casser la t√™te.

Comme tout-√†-l'heure, aller dans `Local types`, saisir le raccourcis `Inser` et copier/coller l'`enum` puis valider :

![](/assets/images/introduction_au_reverse/renum_loc_types.png)

L‚Äô√©num√©ration est cr√©√©e, on peut retourner √† notre fonction `main`.

Cliquez sur le chiffre `0` dans `case 0` puis appuyer sur `M`.

> **Astuce IDA** : Le raccourcis permettant d'assigner √† des constantes des √©num√©rations est `M`.
{: .prompt-tip }

Ensuite s√©lectionnez l'`enum` que l'on vient d'ajouter :

![](/assets/images/introduction_au_reverse/add_enum.png)

En confirmant, le tour est jou√© et on a le r√©sultat attendu :

![](/assets/images/introduction_au_reverse/good_switch.png)

### Les commentaires

On aurait pu tout simplement s'arr√™ter l√† en ce qui concerne l'analyse statique de cette fonction : elle est assez courte et maintenant que les variables et fonctions sont renomm√©es, on sait exactement ce qu'elle fait.

Toutefois, cela nous permettra de voir les raccourcis permettant **d'ins√©rer un commentaire** et les diff√©rents **types de commentaires** utilisables.

Tout d'abord, commen√ßons par les **commentaires en fin d'instruction**.

> **Astuce IDA** : Il est possible de mettre un commentaire sur la m√™me ligne que l'instruction s√©lectionn√©e dans la fen√™tre de d√©compilation avec le raccourcis `/`.
> 
> Dans la fen√™tre du code d√©sassembl√©, cela est possible avec `:` ou `;`.
{: .prompt-tip }

**Exemple** (code d√©compil√©) : 

![](/assets/images/introduction_au_reverse/comm_meme_ligne.png)

**Exemple** (code d√©sassembl√©) :

![](/assets/images/introduction_au_reverse/com_asm.png)

Il est √©galement possible de mettre des **commentaires avant l'instruction**.

> **Astuce IDA** : Vous pouvez utiliser le raccourcis `Inser` pour saisir un commentaire avant l'instruction s√©lectionn√©e.
{: .prompt-tip }

> **Astuce IDA** : En utilisant la touche `Entr√©e`, vous pouvez ajouter des sauts de lignes, pratique lorsque l'on souhaite espacer le code.
{: .prompt-tip }

> J'ai essay√© de sauter des lignes mais j'arrive plus √† les supprimer !
{: .prompt-info }

En fait les **sauts de lignes** sont simplement des **commentaires** pr√©c√©dent une instruction mais qui ne sont constitu√©s que de sauts de lignes. Vous pouvez donc modifier le commentaire pour supprimer les sauts de lignes ajout√©s.

**Exemple** :

![](/assets/images/introduction_au_reverse/comm_avant_inst.png)

## ‚ú® R√©sultat final

Et si on comparait le programme avant et apr√®s *reverse* ?

![](/assets/images/introduction_au_reverse/comparison_decomp.png)

Vous voyez la diff√©rence ? Lorsque tout est bien renomm√© et mis √† sa place, la compr√©hension de la fonction coule de (code) source üòä. On comprend alors plus ais√©ment pourquoi le renommage de fonctions, de variables, l'√©criture de commentaires etc. sont **importants en analyse statique** : cela **simplifie** et **fluidifie** la compr√©hension du code.

Bon, on va pas se mentir, on avait le code source avec nous c'√©tait assez facile üòÜ ! Mais sans code source, aurions-nous r√©ussi le *reverse* aussi facilement üò¢ ?

On a m√™me pas eu besoin de lire de l'assembleur gr√¢ce √† la d√©compilation. De toute fa√ßon, une fois que l'on go√ªte √† la d√©compilation, difficile d'y r√©sister ü•∞!

![](/assets/images/introduction_au_reverse/eat_chiken.gif)

## D'autres outils de d√©compilation

Pour rappel, on a choisi d'utiliser IDA car d√©sormais, il est possible d'utiliser le d√©compilateur dans la version **Freeware** et il est plus ergonomique. M'enfin, ce n'est que mon humble avis üòä.

Evidemment, comme certains pourraient ne pas √™tre d'accord et voudraient utiliser **d'autres outils**, en voici quelques-uns :

- üêâ [**Ghidra**](https://ghidra-sre.org/) : Initialement d√©velopp√© par la NSA et devenu *open source*. Tr√®s pratique pour le *reverse* d'architecture diff√©rentes de **x86** (m√™me s'il fait le travail). Pour *reverser* des programmes Windows, il semble √™tre moins adapt√© ... Quant √† son UI, soit on aime soit on aime pas üòÖ.
- ü•∑ [**Binary Ninja**](https://binary.ninja/) : Outil d√©velopp√© plus r√©cemment et qui est payant. Une version gratuite sur le **cloud** est cependant propos√©e.
- ‚è™ [**Cutter**](https://cutter.re/) : Outil *open source* bas√© sur Rizin.

Encore une fois, l'id√©e n'est pas de se focaliser que sur un seul outil mais de conna√Ætre les **forces et faiblesses** de chacun de ces outils pour savoir quand les utiliser √† bon escient.

## üìã R√©sum√© 

Pour r√©sumer, voici les principaux points √©voqu√©s (sans √™tre exhaustif) :
 
- Il est n√©cessaire d'adopter une **m√©thodologie** et une **strat√©gie d'analyse** pour *reverser* un programme : il n'est souvent pas n√©cessaire ni pertinent d'analyser toutes les fonctions d'un programme en profondeur
- Conna√Ætre sur les bout des doigts les principaux **raccourcis** d'IDA permet d'avancer bien plus vite
- Du code d√©compil√© dont les variables et fonctions appel√©es sont renomm√©es est bien **plus lisible** et plus facilement **compr√©hensible**
- On passe pas mal de temps √† **renommer**, **renommer** et **renommer** 