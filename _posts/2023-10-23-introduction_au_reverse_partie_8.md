---
title: Partie 8 - Analyse statique  d'un mini-programme - les affectations de valeurs, la lecture et √©criture en m√©moire (4/5)
date: 2023-10-23 10:00:00
categories: [Reverse, Introduction au reverse]
tags: [x86, reverse, linux]     # TAG names should always be lowercase
author: kabeche
toc: true
---

# Analyse statique  d'un mini-programme : les affectations de valeurs, la lecture et √©criture en m√©moire (4/5)

Je sais que √ßa fait un petit moment que l'on a laiss√© IDA ouvert sans avoir pris le temps d'avancer sur notre *reverse*, mais maintenant que vous avez les bases dans la gestion de la pile et des registres, nous pouvons y revenir ! 

A pr√©sent que nous savons ce que sont les **registres** et comment fonctionne la **pile**, nous en devrions pas avoir trop de mal √† comprendre ce qui se passe dans la fonction `main`. 

Ce sera √©galement l'occasion de revoir certaines notions et d'en aborder de nouvelles : 

- le **passage des arguments** lors d'un appel de fonction
- la gestion des **variables locales**
- les **boucles**
- les **conditions**
- etc.

## Rappels de la fonction `main`

Pour rappel, voici √† quoi ressemblait notre fonction `main`  :

```cpp
int main()  
{  
 int a = 2;  
 int b = 3;  
  
 return a+b;  
}
```

Et son code d√©sassembl√© par IDA :

![](/assets/images/introduction_au_reverse/main_disassm.png)

Tout d'abord, int√©ressons nous √† ce qui est affich√© entre le `main proc near` et `; __unwind {`. IDA a fait le choix de remplacer certains **offsets** (ou d√©calage m√©moire) avec des noms tels que `var_4`, `argc` etc.

> En *reverse* on utilise √©norm√©ment la notion d'**offset** par rapport √† l'utilisation d'une **adresse "fixe"**.
> 
> Par exemple, on pr√©f√®re dire que la premi√®re variable est situ√©e √† l'adresse `ebp-8` (`-8` √©tant l'**offset**) que de dire qu'elle est situ√©e √† l'adresse `0x7fffff10`.
> 
>  Pourquoi ? Tout simplement car de nos jours, les adresses utilis√©es dans un programme sont al√©atoires ce qui signifie que d'une ex√©cution √† une autre, l'adresse de la variable locale peut changer tandis que `ebp-8` pointera toujours vers la variable en question.
{: .prompt-tip }

## Les offsets des variables et arguments

En fait, parmi les offset qu'IDA renomme, nous pouvons en distinguer 2 cat√©gories :

- ceux qui ont un **offset positif** ‚ûï : ce sont les **arguments**. En effet, il sont situ√©s en dessous de `ebp` comme vu avez pu le constater au pr√©c√©dent chapitre sur la pile.
- ceux qui ont un **offset n√©gatif** ‚ûñ : ce sont les **variables locales**. Elles sont situ√©es au dessus de `ebp`.

![](/assets/images/introduction_au_reverse/vars_and_args_bis.png)

> Pour rappel, comme les adresses basses sont vers le haut, tous les √©l√©ments situ√©s au-dessus d'`ebp` ont donc une adresse plus petite : c'est pourquoi les **variables locales ont un offset n√©gatif**.
> 
> De la m√™me mani√®re, les arguments √©tant situ√©s en-dessous d'`epb`, ces derniers ont un **offset positif**. 
{: .prompt-tip }

> Le fait que les variables locales aient un offset n√©gatif n'est vrai que lorsque l'on utilise l'offset par rapport √† `ebp`. En effet, dans certains cas, il est possible d'utiliser un **offset par rapport √†** `esp` pour acc√©der √† ces variables. Cet offset sera donc **positif** dans ce cas.
> 
> Idem pour les arguments qui ont un offset positifs relativement √† `ebp`, si on utilise `esp`, les offsets seront **n√©gatifs**. 
{: .prompt-warning }

IDA pr√©f√®re en g√©n√©ral utiliser des **noms de variables** pour d√©signer les **variables locales** ou les **arguments**. L'avantage est que l'on sait directement que `ebp+var_8` pointe vers la variable qu'IDA a nomm√© `var_8` car elle se situe √† l'offset `-8` par rapport √† `ebp`. 

Vous vous demandez peut-√™tre pourquoi il n'a pas appel√© les deux variables `a` et `b` comme c'est le cas dans le code source. Et bien c'est tr√®s simple ! IDA ne sait tout simplement pas comment elles s'appellent. Rappelez-vous, lors de la compilation les noms des variables locales **ne sont pas conserv√©s**. Ainsi, lorsque IDA d√©sassemble le programme, il voit seulement que les zones m√©moire `ebp-8` et `ebp-4` sont utilis√©es. IDA en d√©duit alors qu'il s'agit de variables locales qu'il renomme `var_8` et `var_4`.

### `argc`, `argv` et `envp`

> On avait bien deux variables locales dans notre programme. Mais pourquoi IDA liste 3 arguments que sont `argc`, `argv` et `envp` alors que notre fonction `main` ne prend aucun argument ?
{: .prompt-info }

En fait `argc`, `argv` et `envp` sont les 3 arguments que l'on peut donner, ou non, √† une fonction `main` avec :

- `argc` : le nombre d'arguments donn√©s lors du lancement du programme. Par exemple, si le programme est lanc√© ainsi : `./exe arg1 arg2` alors `argc` vaudra 3 et non pas 2. En effet, rappelez-vous, le premier argument d'un programme en C est le nom du programme tel qu'il a √©t√© lanc√©.
- `argv`: un tableau de cha√Ænes de caract√®res o√π chaque √©l√©ment repr√©sente un argument. Le **premier √©l√©ment**, √† l‚Äôindex 0, est donc le **nom du programme**.
- `envp` : un tableau de caract√®res o√π chaque √©l√©ment est une paire `cl√©=valeur` qui correspond aux variables d'environnement. Par exemple : `HOME=/home/username`

Il faut √©galement savoir une chose, bien que dans le code source aucun argument n'est donn√© √† notre fonction `int main()`eh bien `argc`, `argv` et `envp` seront tout de m√™me pr√©sents en m√©moire car ils y sont **toujours ins√©r√©s** au lancement du programme. C'est peut-√™tre la raison pour laquelle IDA cr√©e toujours automatiquement 3 variables √† leur nom.  

## Le code d√©sassembl√©

Nous venons de voir ce que signifiaient les informations situ√©es au-dessus du code assembleur. Entrons d√©sormais dans le vif du sujet : le code assembleur !

Nous n'allons pas revenir en d√©tail sur ce que font les instructions suivantes :
```nasm
push ebp
mov ebp, esp
sub esp, 0x10
```

Il s'agit du **prologue** qui permet d'avoir une *stack frame* assez grande pour y **stocker les variables locales**.

Une fois le prologue termin√©, nous avons les deux instructions suivantes :
```nasm
mov     [ebp+var_8], 2
mov     [ebp+var_4], 3
```

Avant d'aller plus loin, je vous propose que l'on comprenne de **quoi est compos√© une instruction** en assembleur avant de nous int√©resser plus sp√©cifiquement √† l'instruction `mov`.

## Les diff√©rentes syntaxes : Intel et AT&T

J'ai choisi d'√©viter le sujet jusqu'√† pr√©sent afin de ne pas vous surcharger d'informations qui n'√©taient pas n√©cessaires mais celle-ci a son importance afin de ne pas √™tre perturb√© lors de l'utilisation de certains d√©sassembleurs.

Comme vous le savez, apr√®s la compilation d'un programme, on obtient un ex√©cutable qu'il est n√©cessaire de d√©sassembler pour pouvoir lire le code assembleur. N√©anmoins, pour l'assembleur `x86` il y a **deux mani√®res** de lire (ou **syntaxes**) l'assembleur : **Intel** et **AT&T**.

Je vous propose de voir concr√®tement la diff√©rence entre les deux. Allez dans le dossier o√π se trouve le programme `exe` que nous analysons et lancez la commande suivante afin de d√©sassembler via **objdump** le programme avec la syntaxe **Intel** : `objdump -M intel -d exe`.

Nous obtenons ceci pour la fonction `main`:

![](/assets/images/introduction_au_reverse/asm_intel.png)

Rien de nouveau, c'est √©galement comme √ßa qu'IDA a d√©sassembl√© notre fonction `main`. Maintenant d√©sassemblons-le avec la syntaxe **AT&T** via la commande : `objdump -d exe`.

![](/assets/images/introduction_au_reverse/asm_at_e_t.png)

Comme vous pouvez le constater, il s'agit toujours de la m√™me fonction mais celle-ci a √©t√© d√©sassembl√©e, disons, **diff√©remment** üòÖ. En fait, il s'agit tout simplement d'une **mani√®re diff√©rente de repr√©senter** le code assembleur. 

Avant d'expliciter les diff√©rences entre ces deux syntaxes, un peu de vocabulaire :

![](/assets/images/introduction_au_reverse/asm_details_bis.png)

1. **opcode** : il s'agit des octets tels qu'ils sont lus par le processeur et qui aboutit √† l'ex√©cution de l'instruction assembleur associ√©e
2. **mn√©monique** : c'est en quelque sorte le nom de l'instruction ex√©cut√©e
3. **op√©randes** : registres, pointeur ou valeurs concr√®tes utilis√©es par l'instruction

Il est important de garder ces d√©finitions en t√™te car cela fait partie du jargon en *reverse*.

Comme convenu, voici les principales diff√©rences entre ces deux syntaxes :

1. **Ordre de la destination et de la source** :
	- **Intel** : l'op√©rande de **gauche** est la **destination** tandis que l'op√©rande de **droite** est la **source**
	-  **AT&T** : l'inverse. l'op√©rande de **droite** est la **destination** tandis que l'op√©rande de **gauche** est la **source**
2. **Pr√©fixes** utilis√©s :
	-  **Intel** : Pas de pr√©fixes en particuliers
	-  **AT&T** : Les registres sont pr√©fix√©s par `%` et les constantes par `$`
3. **Format des pointeurs** :
	- **Intel** : Les pointeurs vers une zone m√©moire sont plac√©s entre **crochets** avec leur offset. Exemple : `[ebp+8]`
	- **AT&T** : Les pointeurs vers une zone m√©moire sont plac√©s entre **parenth√®ses** et les offsets sont plac√©s avant la premi√®re parenth√®se. Exemple : `8(%ebp)`

Personnellement mon c≈ìur penche vers la syntaxe Intel qui est, selon moi, bien plus lisible que celle d'AT&T avec des `&` et `%` partout üòµ‚Äçüí´. Ce choix est √©videmment subjectif. De tout mani√®re, comme vous avez pu le voir, chaque outil utilise par d√©faut la syntaxe qu'il pr√©f√®re. Ainsi **objdump** utilise par d√©faut la syntaxe **AT&T** tandis qu'**IDA** utilise la syntaxe **Intel**.
## L'instruction `mov`

Revenons √† nos moutons üêè !

L'instruction `mov` tire son nom de *move* qui signifie d√©placer en anglais. Ainsi, cette instruction va permettre de r√©aliser le **d√©placement** d'une valeur d'un endroit √† un autre. A proprement parler il s'agit plus d'une **copie** que d'un d√©placement. Il ne faut donc pas s'imaginer que la zone "source" est mise √† z√©ro par `mov` : elle garde son **contenu inchang√©**.

Voyons ensemble les diff√©rentes mani√®res d'utiliser `mov` car il y en a pas mal ! Je pr√©f√®re que nous les voyons ensemble afin que vous sachiez o√π retrouver ces informations lorsque vous tomberez nez-√†-nez avec une de ces formes.

De plus, selon l'usage, une forme sera utilis√©e plut√¥t qu'une autre. Par exemple, il y a une forme permettant d'**√©crire** ‚úèÔ∏è en m√©moire et une autre d'y **lire** üìÑ.

> Toutes les instructions que nous voyons en d√©tails dans ce cours sont pr√©sentes dans une page **Annexes**.
{: .prompt-tip }

### `mov reg_d, value`

#### Op√©randes 
- `reg_d` : registre de destination
- `value` : valeur imm√©diate (ou concr√®te, constante). 

#### D√©tails 
Cette forme est la plus simple : elle affecte la valeur `value` au registre de destination `reg_d`.

C'est une mani√®re de r√©aliser des affectations de valeurs concr√®tes (imm√©diates).

#### Exemple
Imaginons que `eax` vaille `0xaabbccdd` puis que l'on ex√©cute l'instruction `mov eax, 0xdeadbeef`. Alors la valeur de `eax` sera `0xdeadbeef`.

#### √âquivalent en C

Je vous propose de voir quelques √©quivalents en C (quand c'est possible) des diff√©rentes instructions √©tudi√©es, cela sera peut-√™tre plus simple pour la comprendre.

```cpp
// Initilisation du registre
int x = 0xaabbccdd; // eax

// Equivalent de : mov eax, 0xdeadbeef
x = 0xdeadbeef;
```

### `mov reg_d, reg_s`

#### Op√©randes 
- `reg_d` : registre de destination
- `reg_s` : registre source 

#### D√©tails 
Le contenu du registre source `reg_s` est copi√© dans le registre de destination `reg_d`.

C'est une mani√®re d'affecter le contenu d'une variable √† une autre.
#### Utilisation d'un debugger
Je vous propose d'utiliser un *debugger* d'assembleur pour ex√©cuter pas √† pas des instructions x86. Le site [asmdebugger.com](http://asmdebugger.com/) est assez simple et permet de r√©aliser ce que nous voulons faire.

Il y en a un [autre](https://kobzol.github.io/davis/), assez simple d'utilisation, mais qui a plusieurs inconv√©nients :

1. Il n'est pas possible de modifier la valeur initiale des registres √† la main, nous devrons donc le faire via des instructions du type `mov reg, value`. (M√™me probl√®me chez asmdebugger.com)
2. Il n'est pas possible dans lancer le code directement en mode pas √† pas, mais il y a une astuce pour y parvenir : lancer l'ex√©cution et rapidement appuyer sur "pause", vous aurez alors acc√®s
3. Les valeurs des registres ne sont affich√©s qu'en d√©cimal

#### Exemple 
Alors voici le code assembleur que je vous propose d'ex√©cuter pas √† pas sur  [asmdebugger.com](http://asmdebugger.com/) :

![](/assets/images/introduction_au_reverse/dbg_ex_1.png)

Cliquez ensuite sur `Restart`. Vous pourrez alors cliquer sur `Next instruction` pour ex√©cuter le code assembleur pas √† pas.

Comme il n'est pas possible de donner des valeurs initiales √† la main aux registres, nous le faisons via les deux premi√®res instructions.

Vous pourrez ainsi constater qu'√† l'issue de l'ex√©cution de la derni√®re instruction `mov ebx, eax`, `ebx` vaut d√©sormais `0xaabbccdd`.

**Question** : que se passe-t-il si on ex√©cute le code suivant :
```nasm
mov eax, 0xdd 
mov ebx, 0x11223344 

mov ebx, eax
```

Est-ce que seule l'octet de poids faible de `ebx` va changer ? Je vous propose de tester vous-m√™me sur le *debugger*. Nous aurons amplement le temps de r√©pondre √† cette question en d√©tails ult√©rieurement.

> N'h√©sitez pas √† faire plusieurs tests au fur et √† mesure que nous apprenons de nouvelles instructions assembleur. 
> 
> De cette mani√®re vous serez actifs et cela vous facilitera l'apprentissage et la compr√©hension de l'assembleur. 
{: .prompt-tip }

#### √âquivalent en C

```cpp
// Initilisation des registres
int a = 0xaabbccdd; // eax
int b = 0x11223344; // ebx

// Equivalent de : mov ebx, eax
b = a; // b = 0xaabbccdd
```

### üìÑ `mov reg_d, [reg_p]` 

#### Op√©randes 
- `reg_d` : registre de destination
- `reg_p` : registre pointant vers une zone m√©moire

#### D√©tails 
Cette forme est un peu plus complexe que les pr√©c√©dentes car elle fait appel √† la notion de **pointeur**.

Ici `reg_d` est le registre de destination qui recevra une valeur, jusque-l√† rien de bien nouveau. Par contre, `reg_p` ne contient pas la valeur qui sera copi√©e mais **un pointeur vers la valeur** en question.

Ainsi, c'est la valeur point√©e par `reg_p` qui est copi√©e dans `reg_d`.

C'est une mani√®re de **lire des donn√©es** depuis la **m√©moire**.

#### Exemple
Imaginons que je veuille ex√©cuter ces instructions :

```nasm
mov eax, 0x700000F0
mov ebx, 0xcafebabe

mov ebx, [eax]
```

On suppose √©galement que l'adresse `0x700000F0` pointe vers l'entier de 4 octets `0x1a2b3c4d`.

> Malheureusement les deux sites √©voqu√©s pr√©c√©demment ne permettent pas d'initialiser ou manipuler facilement la m√©moire, nous allons donc nous contenter de sch√©mas, √† d√©faut de pouvoir utiliser des *debuggers* plus puissants.
> 
> Mais ne vous inqui√©tez pas, une partie d√©di√©e √† l'utilisation d'un "vrai" *debugger* arrive ! 
{: .prompt-tip }

L'√©tat des registres avant l'ex√©cution de `mov ebx, [eax]` est le suivant :

![](/assets/images/introduction_au_reverse/mov_mem_asm_bis.png)

Lorsque la derni√®re instruction `mov ebx, [eax]` sera ex√©cut√©e, alors `ebx` vaudra `0x1a2b3c4d`. Vous voyez la logique ?

#### L√©g√®res variantes

Il existe quelques variantes o√π un offset (positif ou n√©gatif) est ajout√© au registre `reg_p`, par exemple :

```nasm
mov edx, [eax + 8]
mov ecx, [esi - 0x2000]
```

#### √âquivalent en C

Cette forme est tr√®s similaire √† l'utilisation de pointeurs en C :

```cpp
// Initilisation des registres
int *a = 0x700000f0; // eax
int b = 0xcafebabe; // ebx

// Initilisation de la m√©moire 
*a = 0x1a2b3c4d;

// Equivalent de : mov ebx, [eax]
b = *a; // b = 0x1a2b3c4d
```

Vous comprenez maintenant pourquoi conna√Ætre le C est un pr√©requis avant d'entamer le reverse ü§ì ? √áa nous facilite pas mal la compr√©hension des instructions assembleur !

### ‚úèÔ∏è `mov [reg_p], reg_s`

#### Op√©randes 
- `reg_p` : registre pointant vers une zone m√©moire
- `reg_s` : registre source

#### D√©tails 

Normalement, si vous avez bien saisi le principe de l'instruction `mov reg_d, [reg_p]` vous devriez deviner le fonctionnement de celle-ci.

En fait il s'agit de l'inverse de la pr√©c√©dente instruction. En effet, ici on copie la valeur du registre `reg_s` vers la zone m√©moire point√©e par `reg_p`.

C'est une mani√®re d'**√©crire des donn√©es** en **m√©moire**.
#### Exemple

Reprenons le pr√©c√©dent exemple, nous avions initialement :

![](/assets/images/introduction_au_reverse/mov_mem_asm_bis.png)

Que se passe-t-il si j'ex√©cute d√©sormais `mov [eax], ebx` ?

Eh bien apr√®s l'ex√©cution de cette instruction, ces deux registre et cette zone m√©moire seront dans cet √©tat :

![](/assets/images/introduction_au_reverse/mov_mem_asm_2_bis.png)

#### L√©g√®res variantes

Il existe quelques variantes o√π un offset (positif ou n√©gatif) est ajout√© au registre `reg_p`. Il est √©galement possible de remplacer `reg_s` par une valeur imm√©diate. Par exemple :

```nasm
mov [ebp + 8], edi
mov [esi - 0x200], 0xdeadbeef
```
#### √âquivalent en C

```cpp
// Initilisation des registres
int *a = 0x700000f0; // eax
int b = 0xcafebabe; // ebx

// Initilisation de la m√©moire 
*a = 0x1a2b3c4d; // 0x700000f0 -> 0x1a2b3c4d

// Equivalent de : mov [ebx], eax
*a = b; // 0x700000f0 -> 0xcafebabe
```

> Il n'existe pas d'instruction permettant **directement** de d√©placer des donn√©es d'une zone m√©moire √† une autre du type : `mov [reg_p_d],[reg_p_s]`.
>
> Pour plus d'informations, c'est par [ici](https://stackoverflow.com/questions/33794169/why-isnt-movl-from-memory-to-memory-allowed) (en üá¨üáß).
{: .prompt-warning }

> Il existe d'autres formes mais moins courantes. Ces quatre-l√† sont les principales, les autres √©tant des variations ou d√©riv√©es.
> 
> Vous pouvez avoir la liste de toute les formes [ici](https://c9x.me/x86/html/file_module_x86_id_176.html) (attention les yeux ü•∂). 
{: .prompt-tip }

### R√©sum√© des diff√©rentes formes

Je sais, √ßa fait beaucoup d'informations d'un coup, voici ainsi un r√©sum√© avec un exemple pour chacun des 4 formes possibles. Supposons que dans les 4 cas l'√©tat initial est le suivant :

![](/assets/images/introduction_au_reverse/init_mov_asm_bis.png)

Alors le r√©sultat est : 

![](/assets/images/introduction_au_reverse/mov_summary.png)

> Les valeurs en üî¥ sont celles qui ont chang√© lors de l'ex√©cutions de l'instruction tandis que celles en ‚ö´ sont les valeurs √† l'origine du changement.
{: .prompt-tip }

Pour le coup, il est int√©ressant d'apprendre ces diff√©rentes formes car nous verrons par la suite de nouvelles instructions qui ont √©galement diff√©rentes formes. Par exemple, pour comparer deux valeurs :

```nasm
cmp ecx, 0x12
cmp rdi, rsi
cmp rax, [rbp + 8]
```

Normalement, si vous avez compris le principe avec `mov`, vous devriez comprendre quels sont √† chaque fois les deux valeurs compar√©es dans ces 3 pr√©c√©dentes instructions.

## L'instruction `lea`

J'ai choisi de mettre cette instruction dans ce chapitre car m√™me si on ne l'a pas encore vue, elle peut √™tre parfois **mal comprise**. De plus, elle ressemble en quelque sorte √† un `mov` donc autant en parler d√®s √† pr√©sent.

`lea` signifie *Load Effective Address*. Cette instruction est principalement utilis√©e pour **charger des adresses**, avec ou sans offset ajout√©. 
### `lea reg, [...]`

#### Op√©randes 
- `reg` : registre de destination
- `[...]` : valeur qui est souvent une adresse m√©moire

#### D√©tails 

Cette instruction a ainsi une seule forme o√π la premi√®re op√©rande est toujours un registre, la seconde op√©rande est une valeur qui est souvent une adresse vers une zone m√©moire. 

Ce que fait `lea` est tout simplement la copie de l'op√©rande de droite, **sans la d√©r√©f√©rencer**, vers le registre de destination.

Voici quelques exemples :

```nasm
lea eax, [0x400000] ; ici eax = 0x400000 
lea edx, [ebp+8]    ; ici edx = ebp +8
lea ecx, [ebx+eax]  ; ici ecx = ebx+eax
```

#### Exemple

> Comme `lea` ne d√©r√©f√©rence pas la seconde op√©rande, l'instruction `lea eax, [0x400000]` copie bien `0x400000` dans `eax` et non pas la valeur point√©e par `0x400000`.
{: .prompt-warning }

En fait, plus simplement, `lea` copie la valeur entre les crochets vers le registre de destination. En d'autres termes, `lea reg, [...]` est √©quivalente √† `mov reg, ...`.

J'en vois d√©j√† certains froncer les sourcils ü§®.

> Mais si cela est √©quivalent √† faire un `mov`, pourquoi se casser la t√™te avec une instruction en plus ?
{: .prompt-info }

En fait, contrairement √† `mov`, l'instruction `lea` permet de faire de petites op√©rations au niveau de l'op√©rande de droite. Par exemple, si je souhaite affecter √† `ecx` la somme de `ebx` et `eax` en utilisant `mov`, je suis oblig√© d'utiliser une instruction suppl√©mentaire telle que `add` pour faire l‚Äôaddition et ensuite stocker le r√©sultat dans `ecx` avec `mov`.

Tandis qu'avec `lea`, je peux simplement faire : `lea ecx, [ebx + eax]`. Vous savez quoi ? On peut m√™me faire `lea ecx, [ebx + eax*2]`üòé.

Ainsi, `lea` permet de :

- **Stocker** le r√©sultat de **simples op√©rations** en √©crivant une seule instruction
- De **manipuler des adresses** en y ajoutant, ou non, un offset

> S'il n'y avait qu'une seule chose √† retenir de `lea` : il s'agit d'un `mov` qui copie la "valeur entre crochets" vers la destination.
{: .prompt-tip }
