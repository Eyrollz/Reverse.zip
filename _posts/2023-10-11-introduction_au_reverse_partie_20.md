---
title: Partie 20 - L'analyse dynamique - d√©bogage d'un programme (2/4)
date: 2023-10-11 10:00:00
categories: [Reverse, Introduction au reverse]
tags: [x86, reverse, linux]     # TAG names should always be lowercase
author: kabeche
toc: true
---

# L'analyse dynamique : d√©bogage d'un programme (2/4)

Et si on laissait la th√©orie de c√¥t√© un instant et que l'on mettait la main √† la p√¢te, √ßa vous dit ?

> Dans ce chapitre nous allons d√©couvrir de nombreuses **commandes** propres √† gdb, je vous propose de les noter dans un coin (feuille de brouillon, notes ...), cela vous sera tr√®s utile quand vous d√©boguerez un programme de votre c√¥t√©.
> 
> Dans tous les cas, elles sont pr√©sentes dans les annexes de ce cours.
{: .prompt-tip }

Tout d'abord, si ce n'est pas d√©j√† le cas, installez **gdb**. Pour les distros debian like : `sudo apt install gdb`. Je vous propose √©galement d'installer l'extension [pwndbg](https://github.com/pwndbg/pwndbg).

En effet, la version **gdb de base**, bien que fonctionnelle, n'est **pas du tout ergonomique** :

- il faut toujours afficher les registres **soit m√™me**
- les instructions autour de l'instruction en cours d'ex√©cution ne sont **pas affich√©es**
- et puis, √ßa manque de **couleurs** de tout √ßa !

Ainsi, **pwndbg** va nous faciliter la vie et nous permettre d'aller plus vite. Pour installer **pwndbg** il suffit de suivre les instructions d'installation sur leur d√©p√¥t GitHub.

> Il ne faut pas confondre **pwndbg** et **pwngdb** qui sont deux extensions diff√©rentes de gdb.
> 
> Il est possible d'utiliser les deux en m√™me temps afin d'avoir plus de fonctionnalit√©s mais il semblerait que `pwngdb` ne soit pas assez √† jour pour √™tre utilis√© avec **pwndbg** actuellement.
> 
> Si vous trouver une mani√®re d'installer les deux dans leur version r√©cente, je suis preneur üòÖ !
{: .prompt-warning }

Une fois l'installation termin√©e, nous pouvons faire joujou avec notre nouveau jouet.

Je vous propose de tester gdb avec le programme suivant :

```cpp
#include "stdio.h"
int calcul(int a, int b, int c)  
{  
 return a + b*c;  
}  

int main()  
{  
  
 int a = 1;  
 int b = 2;  
 int c = 3;  
  
 calcul(a,b,c);  
    
 a = 4;  
 b = 5;  
 c = 6;  
    
 calcul(a,b,c);  
  
 a = 7;  
 b = 8;  
 c = 9;  
    
 calcul(a,b,c);  
  
 puts("Travail termin√©√©√©√©√© !");  
  
 return 0;  
}
```

Compilons-le avec `gcc main.c -o exe`.

## D√©marrage du d√©bogage

Pour commencer √† d√©boguer notre programme fra√Æchement compil√©, il suffit de lancer `gdb ./exe`. Vous devriez avoir quelque chose qui ressemble √† ceci :

![](/assets/images/introduction_au_reverse/gdb_init.png)

> Ok mais o√π est notre programme d√©bogu√© ? Je le vois nulle part ! üò¥
{: .prompt-info }

C'est normal ! A ce stade, **gdb** est √† peine lanc√© et a lu les diff√©rents symboles (noms de fonctions, variables globales ...) pr√©sents dans le programme. 

Nous pouvons lancer l'ex√©cution du programme d√©bogu√© avec la commande `run`.

> Si un programme accepte des arguments via `argv`, il est possible de les sp√©cifier lors de la commande `run`.
> 
> Exemple : `run arg1 arg2`
{: .prompt-tip }

On obtient ceci :

![](/assets/images/introduction_au_reverse/run_gdb.png)

Notre programme s'est bien ex√©cut√© !

> C'est un blague ! Tu nous as dit qu'on allait pouvoir lire la valeur des registres, inspecter la m√©moire etc. mais on a eu rien de tout √ßa ! On aurait eu exactement le m√™me r√©sultat en l'ex√©cutant normalement üò† !
{: .prompt-info }

Alors effectivement ex√©cuter un programme d'une traite dans gdb n'est pas ce qu'il y a de plus int√©ressant. Commen√ßons donc √† voir ce qu'il propose afin de comprendre en quoi l'analyse dynamique est tr√®s utile.

## üî¥ Les points d'arr√™t

Les points d'arr√™t (ou *breakpoints* üá¨üáß) sont des marqueurs plac√©s sur certaines instructions (plus pr√©cis√©ment sur l'adresse de l'instruction). Lorsque le processus atteindra l'instruction sur laquelle il y a un point d'arr√™t (`rip == addr_marqu√©e `), gdb va suspendre l'ex√©cution du programme. Cela nous permet ensuite de pouvoir analyser pas mal de choses.

Il existe principalement deux types de *breakpoints* :

- Les **hardware breakpoints** (points d'arr√™ts mat√©riels)
- Les **software breakpoints** (points d'arr√™ts logiciels)

Le point commun entre les deux est que lorsque le processus arrivera √† un point d'arr√™t, mat√©riel ou non, l'ex√©cution sera stopp√©e. La diff√©rence entre les deux est la mani√®re dont ils sont impl√©ment√©s.

Pour faire simple :

- Les points **d'arr√™t logiciels** sont impl√©ment√©s via l'insertion artificielle d'une instruction permettant stopper l'ex√©cution du programme. En x86, cette instruction est l'interruption `int 3` dont l'opcode est `0xcc`.
- Les points **d'arr√™t mat√©riels** sont impl√©ment√©s via des [registres du processeur d√©di√©s](https://en.wikipedia.org/wiki/X86_debug_register) √† cet effet : `DR0`, `DR1`, `DR2` ... Ainsi, nul besoin d'ins√©rer une instruction dans le code.

Dans le cas d'un programme prot√©g√© (*crackme*, *malware*, programme propri√©taire, jeu vid√©o ...), il est plus facile de d√©tecter les points d'arr√™t logiciels (en raison de l'insertion de `int 3`) que les mat√©riels (mais pas impossible !). Ainsi, si vous pensez que le programme que vous analysez est prot√©g√©, il vaut mieux commencer par utiliser des **points d'arr√™t mat√©riels** avant d'utiliser les points d'arr√™t logiciels.

> **Astuce gdb** : La commande `hb *0xaddr` (*hardware breakpoint*) permet d'ins√©rer un point d'arr√™t mat√©riel √† l'adresse `0xaddr` .
{: .prompt-tip }

Le souci des *hardware breakpoints* est qu'il y en a un nombre limit√© (car il y a un nombre limit√© de registres de d√©bogage) et que tous les processeurs ne supportent pas cette fonctionnalit√©. En revanche, les *softwares breakpoints*, en veux-tu en voil√† !

> Dans la suite de cours, par souci de concision, le terme point d'arr√™t (*breakpoint*) d√©signera un point d'arr√™t logiciel.
{: .prompt-tip }

### L'insertion de points d'arr√™ts

Nous pouvons utiliser le raccourcis `b nom_de_fonction` de gdb afin d'ins√©rer un point d'arr√™t au niveau de la **premi√®re instruction** de la fonction ci celle-ci dispose d'un symbole.

> **Astuce gdb** : Pour les fonctions dont le symbole n'est pas disponible (ex: programme *stripp√©*), il est possible d'utiliser l'adresse de la fonction : `b *0x401020`.
> 
> Notez bien l'ast√©risque avant l'adresse. Elle est indispensable lorsque l'on utilise des adresses sinon gdb ne va pas aimer du tout.
> 
> En temps normal, si un programme est **PIE**, l'adresse du `main` changera √† chaque ex√©cution √† cause de l'**ASLR**. Heureusement **pwndbg** d√©sactive automatiquement l'ASLR √† chaque fois que l'on ouvre **gdb**. Vous pouvez **activer l'ALSR** avec la commande : `set disable-randomization off`.
{: .prompt-tip }

Cette fois-ci, avant de lancer l'ex√©cution, mettons un point d'arr√™t sur la fonction `main` afin de stopper l'ex√©cution une fois arriv√©s √† sa premi√®re instruction :

![](/assets/images/introduction_au_reverse/b_main.png)

> **Astuce gdb** : Vous pouvez utiliser `i b` (pour `info breakpoints`) afin de lister les points d'arr√™ts du programme.
> 
> Cela est tr√®s utile pour s'y retrouver. Chaque point d'arr√™t ayant un num√©ro unique, il sera affich√© dans cette commande.
{: .prompt-tip }

> **Astuce gdb** : Pour supprimer un point d'arr√™t vous pouvez utiliser  `d N` (pour `delete N`) afin de supprimer le *breakpoint* num√©ro `N`.
{: .prompt-tip }

Le point d'arr√™t est en place, lan√ßons le programme avec `run` et l√† ...

![](/assets/images/introduction_au_reverse/pikachu.png)

## Comprendre l'interface de gdb (pwndbg)

Alors oui, de prime abord cela peut para√Ætre surprenant mais vous verrez que ce sont des informations **tr√®s utiles** ! Essayons de les d√©cortiquer ensemble.

![](/assets/images/introduction_au_reverse/pwndbg.png)

- **Point d'arr√™t d√©clench√©** : le num√©ro du point d'arr√™t **atteint** et l'adresse √† laquelle l'ex√©cution du processus a √©t√© arr√™t√©e.
- **Registres** : la liste des principaux registres. Quand le registre contient une adresse (pointeur) valide, gdb la d√©r√©f√©rence et ainsi de suite. Par exemple, ici, `rsi` contient `char **argv`, c'est pourquoi on a `rsi = argv -> &argv[0] -> chemin_du_programme`.
- **Prochaine instruction ex√©cut√©e** : le nom est explicite. Nous verrons plus tard comment ex√©cuter des instructions pas √† pas.  
- **Instructions suivantes d√©sassembl√©es** : il s'agit des instructions suivantes qui peuvent √™tre ex√©cut√©e. C'est plut√¥t sympa qu'elles soient d√©sassembl√©es et affich√©es directement, cela nous permet de nous situer plus facilement dans le code.
- **Premi√®res valeurs de la pile** : √ßa peut √™tre pratique d'avoir les premi√®res valeurs sous le nez, notamment pour y lire les arguments lorsqu'ils sont transmis de cette mani√®re (ex : x86).
- **Trace d'appels** : si vous vous rappelez du chapitre sur la pile, vous devriez vous souvenir que lors de l'appel d'une fonction, une *stack frame* est mise en place afin de g√©rer les variables locales de la fonction appel√©e ainsi que le retour de fonction vers la fonction appelante. En l'occurrence, dans cet endroit vous avez les diff√©rents appels de fonctions qui ont pr√©c√©d√©s l'appel √† `main`. 

Vous remarquerez, si vous jetez un ≈ìil √† la deuxi√®me ligne, que **pwndbg** utilise un **code couleur** ma foi tr√®s utile pour savoir o√π se situe et ce que contient une adresse ou zone m√©moire.

> **Astuce gdb** : Vous pouvez lister les zones m√©moire mapp√©es avec la commande `libs`.
{: .prompt-tip }

## Avancer dans un processus dans gdb

Parfois, l'utilisation des *breakpoints* ne suffit pas √† analyser correctement le comportement d'un programme. Il faut alors une granularit√© d'ex√©cution encore **plus fine**. √áa tombe bien, gdb nous permet d'ex√©cuter **pas √† pas** un programme, c'est-√†-dire **instruction par instruction**.

Cela est tr√®s utile pour diverses raisons :

- Comprendre **ce que fait une instruction**
- Voir les **registres modifi√©s** par une instruction
- Dans le cas de **sauts dynamiques** (ex : `call rax`), voir o√π l'on risque de sauter apr√®s l'ex√©cution de l‚Äôinstruction
- Voir laquelle des **deux branches** va √™tre prise lors d'un saut (ex : `jz 0x405030`)

Tout d'abord, il y a une instruction tr√®s utile lorsque l'on souhaite charger en m√©moire un programme dans gdb sans commencer √† l'ex√©cuter.

> **Astuce gdb** : L'instruction `starti` permet de charger le programme en m√©moire et de **s'arr√™ter √† la premi√®re instruction** de ce dernier, **sans l'ex√©cuter**.
{: .prompt-tip }

Cette commande est tr√®s utile pour charger le programme et voir o√π est charg√© le programme (et donc l'adresse du `main`) via la commande `libs`.

> Si vous n'arrivez pas √† comprendre ce que repr√©sentent les premi√®res lignes de ce qu'affiche `libs`, je vous invite √† jeter un ≈ìil au chapitre `Les segments et sections` que l'on a vu √† la page 3 (ou autour) pour vous rafra√Æchir la m√©moire üòä. 
{: .prompt-tip }

Je vous propose de quitter gdb puis rouvrir `exe` dans gdb et lancer `starti`.

> **Astuce gdb** : Vous pouvez quitter gdb avec les commandes `quit` ou `exit`. De mani√®re plus rapide, vous pouvez utiliser `Ctrl+D`.
{: .prompt-tip }

Normalement vous devriez avoir plus ou moins ceci avec la commande `libs` (tronqu√©):

![](/assets/images/introduction_au_reverse/libs_out.png)

### üîÑ Synchroniser gdb et IDA

J'en profite un instant pour vous partager une astuce pour ne pas avoir de soucis de "d√©synchronisation" entre les adresses utilis√©es par IDA et celle dans gdb.

En ouvrant le programme `exe` dans IDA on voit que la fonction `main` est √† l'adresse `0x116A` (peut diff√©rer chez vous) alors que dans gdb elle est √† l'adresse `0x55555555516a` : 

![](/assets/images/introduction_au_reverse/p_main.png)

> Nous verrons un peu plus tard en d√©tails comment **afficher** des valeurs, pointeurs, registres dans gdb. 
{: .prompt-tip }

> Comment faire alors pour les adresses affich√©es dans gdb et IDA concordent ?
{: .prompt-info }

Une solution est la suivante : rebaser notre programme dans IDA en utilisant la base de gdb. Ce que l'on entend par **base** est **l'adresse de base** (merci Sherlock üïµÔ∏è‚Äç‚ôÇÔ∏è) √† laquelle est charg√© le programme. Il s'agit de la premi√®re adresse affich√©e par `libs`, dans mon cas c'est `0x555555554000`.

En effet, comme le programme est PIE, l'adresse de chaque instruction n'est en fait qu'un offset par rapport √† l'adresse de base du programme (plus pr√©cis√©ment du segment de code).

> **Astuce IDA** : Une fois que vous avez trouv√© l'adresse de base de votre programme, il suffit, dans IDA, d'aller dans `Edit` ‚û°Ô∏è `Segments` ‚û°Ô∏è `Rebase program` puis saisir l'adresse de base trouv√©e dans gdb avec `libs` et cliquer sur `Ok`.
> 
> Tadaaa ! Les adresses des instructions, fonctions etc. sont d√©sormais les m√™mes !
{: .prompt-tip }

Cette astuce vous sera tr√®s utile lorsque vous manipulerez des programme PIE *stripp√©s* et que vous ne pourrez plus vous contenter d'un simple `b main` pour mettre un point d‚Äôarr√™t sur le `main` üòé.

### üë£ Avancer pas √† pas dans un processus

Il existe **diff√©rentes** mani√®re d'**avancer** dans l'ex√©cution d'un programme dans gdb, parmi celles-ci il y a :

- avancer **d'une instruction**
- avancer jusqu'√† **rencontrer un point d'arr√™t**
- avancer jusqu'√† **sortir de la fonction** courante

#### ‚èØÔ∏è Avancer d'une instruction

> **Astuce gdb** : Pour ex√©cuter l'instruction courante et s'arr√™ter √† la prochaine, il est possible d'utiliser `si` ou `ni` (pour `step instruction` et `next isntruction`).
> 
> La diff√©rence entre les deux est que lors de l'appel d'une fonction, `ni` ex√©cute la fonction jusqu'au retour alors que `si` entre dans la fonction et s'arr√™te √† la premi√®re instruction.
{: .prompt-tip }

En utilisant `si`, il est possible d'ex√©cuter pas √† pas le programme et voir les registres modifi√©s qui sont alors affich√©s en rouge üî¥ alors que ceux qui n'ont pas √©t√© modifi√©s depuis sont affich√©s en blanc ‚ö™. 

> **Astuce gdb** : Le fait de saisir √† chaque fois `si` pour avancer d'une instruction peut √™tre fastidieux üò§. Vous pouvez ~~spammer~~ utiliser la touche `Entr√©e` dans le terminal gdb afin de r√©-ex√©cuter la derni√®re commande que vous avez lanc√©e pr√©c√©demment.
{: .prompt-tip }

#### ‚è≠Ô∏è Avancer jusqu'au prochain point d'arr√™t 

Quand un programme est **volumineux** ou que certaines boucles ou fonctions sont **longues**, avancer instruction par instruction se r√©v√®le beaucoup **trop long**. Il est alors possible de mettre un point d'arr√™t vers l'adresse que l'on souhaite atteindre et poursuivre l'ex√©cution jusqu'√† celle-ci.

> **Astuce gdb** : Vous pouvez utiliser la commande `c` (ou `continue`) pour poursuivre l'ex√©cution du processus jusqu'√† arriver √† un point d'arr√™t.
{: .prompt-tip }

> Lorsque vous mettez un point d'arr√™t sur une adresse en vue de vous y arr√™ter en lan√ßant `c`, il se peut que le point d'arr√™t ne soit pas atteint auquel cas le programme termine (ou fasse autre chose).
> 
> Imaginez que vous souhaitiez vous arr√™ter √† la fonction de chiffrement d'un ran√ßongiciel en y mettant un point d'arr√™t mais que vous vous √™tes tromp√©s de fonction ou que plusieurs fonctions de chiffrement sont disponibles. Le fait de poursuivre avec `c` va continuer l'ex√©cution sans s'arr√™ter et l√†, bonjour les d√©g√¢ts  ‚ò¢Ô∏è‚ò£Ô∏èüí£ !
> 
> Pour pr√©venir ce genre de sc√©narios, quand vous analysez du code dangereux, assurez-vous de mettre des garde-fous pour ne pas ex√©cuter le reste du programme. 
{: .prompt-danger }

Nous avions vu la commande `run` pour lancer un programme. Si des points d'arr√™t sont d√©j√† pr√©sents dans le programme et qu'ils sont atteints, alors `run` s'y arr√™tera.

#### ‚§¥Ô∏èAvancer jusqu'au sortir de la fonction courante

Quand on fait du *reverse* en analyse dynamique, on veut souvent aller vite et ne pas perdre de temps √† analyser du code qui n'est pas int√©ressant. Ainsi, si on se retrouve dans une fonction que l'on a d√©j√† analys√©e ou dans une fonction de la libc, par exemple, il n'y a pas tellement **d'int√©r√™t** √† ex√©cuter toute la fonction instruction par instruction.

Une m√©thode fastidieuse serait de mettre un point d'arr√™t √† l'adresse o√π retourne la fonction une fois qu'elle a fini son ex√©cution mais cela implique de trouver l'adresse en question.

Une m√©thode plus simple est d'utiliser la commande `finish`.

> **Astuce gdb** : Vous pouvez utiliser le raccourcis `fin` (ou `finish`) pour finir l'ex√©cution d'une fonction jusqu'√† atteindre l'adresse de retour et s'y arr√™ter.
{: .prompt-tip }

## üìù Exercice 

Je vous propose de r√©aliser  un petit exercice pour vous familiariser un peu avec gdb et les commandes de d√©placement.

üéØ **L'objectif** :  retrouver les arguments de chaque appel √† la fonction `calcul` en **analyse dynamique** seulement.

Comme √ßa c'est facile, on a le **code source** sous les yeux et le cas √©ch√©ant on pourrait d√©compiler le programme pour savoir la r√©ponse. Mais le but est de faire l'exercice en s'aidant **seulement de gdb**.

üí™ Si vous souhaitez vous **entra√Æner davantage**, vous pouvez *stripper* le programme afin de retirer les symboles et apprendre √† mettre des points d'arr√™t en utilisant les adresses. 

üí° **Astuce n¬∞1**  

`UXVlbGxlIGVzdCBsYSBjb252ZW50aW9uIGQnYXBwZWwgdXRpbGlzw6llID8gT8O5IGRldnJhaWVudCBkb25jIMOqdHJlIHN0b2Nrw6lzIGxlcyBhcmd1bWVudHMgPw==`

üí° **Astuce n¬∞2**

`QXZvbnMtbm91cyByw6llbGxlbWVudCBiZXNvaW4gZCdleMOpY3V0ZXIgbGEgZm9uY3Rpb24gImNhbGN1bCIgcGFzIMOgIHBhcyA/`

